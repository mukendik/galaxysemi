-- ---------------------------------------------------------
-- DO NOT EDIT THIS FILE UNLESS:
-- o To customize the update
-- o To execute it manually
-- ---------------------------------------------------------


-- ---------------------------------------------------------
-- CAUTION/INFO/QUESTION messages below are not commented to make sure that
-- scripts are in the right state before to be ran manually
-- ---------------------------------------------------------
CAUTION: When manually running this script, perform the following four steps:
CAUTION: 1. Uncomment the line below and specify a working database.
-- use database_name_xx;
CAUTION: 2. To catch all errors, comment each line "DECLARE EXIT HANDLER FOR SQLEXCEPTION" (if it exists) as shown below:
CAUTION: -- DECLARE EXIT HANDLER FOR SQLEXCEPTION
CAUTION: 3. Before running the first TDR update script, run the script common_update_initialize.sql, then tdr_update_initialize.sql.
CAUTION: 4. After running the last TDR update script, run the script tdr_update_finalize.sql, then common_update_finalize.sql.

CALL is_compatible_version(25, @status, @message);

INFO:This TDR update performs normal updates and adds a primary key to all tables. To minimize downtime while the TDR is being updated, this update process transfers data in the biggest tables in a background thread while resuming data insertion in parallel.
INFO:
INFO:For the "biggest tables" identified in a gexdb_mysql_update_b25_to_b26.sql file for the background transfer:
INFO: - the table name has '_background' appended to it;
INFO: - a new empty table is generated from the original '_background' table;
INFO: - the new empty table has the same structure as the original '_background' table;
INFO: - a primary key is added to the new empty table.
INFO: - the new empty table is updated with data from the original '_background' table in a background thread;
INFO:
INFO:Tables that are not identified in the background update are updated in the normal way (alter table) with a primary key added to each table.
INFO:
INFO:This TDR update supports HOT_COPY (for example: HOT_COPY = current week) so that recent data is available for data consolidation with fresh data arriving from data insertion.
INFO:HOT_COPY is disabled by default, because it can easilly be very time consuming. To avoid incorrect binning consolidations, files will be delayed if data for the same lot are still to be background transferred.
INFO:
INFO:The new background transfer capability can be customized by editing the 'BACKGROUND TRANSFER OPTIONS' section in <installation dir>/install/mysql/gexdb_mysql_update_b25_to_b26.sql.
INFO:To change the default options for the TDR update, edit this file, and save it before starting the TDR update by clicking the 'Yes' button below.
INFO:
QUESTION: Continue the update?

-- ---------------------------------------------------------
-- START UPDATE
-- ---------------------------------------------------------
CALL start_update('GEXDB V3.02 B26 (MySQL)', 302, 26, @status, @message);
CALL add_status('UPDATING_CONSOLIDATION_TRIGGERS', @status, @message);
CALL add_status('UPDATING_CONSOLIDATION_TABLES', @status, @message);
CALL add_status('UPDATING_CONSOLIDATION_PROCEDURES', @status, @message);
CALL add_status('UPDATING_INDEXES', @status, @message);

-- ---------------------------------------------------------
-- BACKGROUND TRANSFER OPTIONS
-- ---------------------------------------------------------
-- HERE THE OPTIONS FOR THE BACKGROUND UPDATE
-- MUST CONTAIN ONLY TABLES WITH splitlot_id COLUMN
-- CAN BE MODIFIED

-- Following default settings activate the background transfer for run and results tables,
-- and transfers 1 week old data for these tables before starting the background transfer.

-- Option BACKGROUND_TRANSFER: enables or disables the background transfer
-- possible values: ENABLED | DISABLED
-- default value: ENABLED
CALL background_transfer_add_settings('BACKGROUND_TRANSFER','ENABLED', @status, @message);

-- Option BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION: minimum duration (in seconds) of 1 transfer step.
--   Makes sure a transfer step run at least this amount of time, even if the number of splitlot defined
--   by BACKGROUND_TRANSFER_INCREMENT is already reached.
-- possible values: unsigned integer > 1
-- default value: 60
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION','60', @status, @message);

-- Option BACKGROUND_TRANSFER_SCHEDULER_FREQUENCY: frequency at which the background transfer event is triggered to execute one transfer step.
-- possible values: <value> <unit> with <value> unsigned integer > 1 and <unit> in [YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND]
-- default value: 60 SECOND
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_SCHEDULER_FREQUENCY','60 SECOND', @status, @message);

-- Option BACKGROUND_TRANSFER_INCREMENT: nb. of splitlots to transfer during one table transfer step.
-- possible values: unsigned integer > 1
-- default value: 100
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_INCREMENT','100', @status, @message);

-- Option HOT_COPY: all splitlots older then this date will be transferred during the update, and before starting the background transfer.
-- possible values: MySQL DATE
-- default value: DISABLED
-- Uncomment following line to enable hot copy
-- CALL background_transfer_add_settings('HOT_COPY',(SELECT curdate() - INTERVAL 1 WEEK), @status, @message);

-- Option TABLE: list of tables for the background update
--   Add all high-volume tables you consider time consumming for the update
CALL background_transfer_add_settings('TABLE','ft_run', @status, @message);
CALL background_transfer_add_settings('TABLE','et_run', @status, @message);
CALL background_transfer_add_settings('TABLE','wt_run', @status, @message);
CALL background_transfer_add_settings('TABLE','ft_ptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','et_ptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','wt_ptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','ft_mptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','wt_mptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','ft_ftest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','wt_ftest_results', @status, @message);

-- ---------------------------------------------------------
-- END OF BACKGROUND TRANSFER OPTIONS
-- ---------------------------------------------------------

CALL background_transfer_check_settings(@status, @message);

-- Prepare the BackGround update
CALL background_transfer_initialization(@status, @message);

-- ---------------------------------------------------------
-- UPDATE DATA
-- ---------------------------------------------------------
CALL background_transfer_add_custom_transfer_description('ft_ptest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_ptest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_ptest_results','ORDER BY','splitlot_id,ptest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_ptest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_ptest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_ptest_results','ORDER BY','splitlot_id,ptest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ptest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ptest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ptest_results','ORDER BY','splitlot_id,ptest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_mptest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_mptest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_mptest_results','ORDER BY','splitlot_id,mptest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_mptest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_mptest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_mptest_results','ORDER BY','splitlot_id,mptest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_ftest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_ftest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_ftest_results','ORDER BY','splitlot_id,ftest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ftest_results','INIT','SET @RUN:=1;SET @INC:=0', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ftest_results','testseq','((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ftest_results','ORDER BY','splitlot_id,ftest_info_id,run_id', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_run','part_status','NULL', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','part_status','NULL', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','part_status','NULL', @status, @message);


-- ---------------------------------------------------------
-- ADD COLUMNS FOR PRIMARY KEYS
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'et_ptest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_ftest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_mptest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_ptest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_ftest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_ptest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_mptest_results', 'testseq', 'SMALLINT UNSIGNED NOT NULL DEFAULT \'0\'  AFTER run_id', @status, @message);
CALL add_column_if_not_exists(Database(), 'gexdb_log', 'log_id', 'INT NOT NULL PRIMARY KEY AUTO_INCREMENT  FIRST', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_wyr', 'wyr_id', 'INT NOT NULL PRIMARY KEY AUTO_INCREMENT  FIRST', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_wyr', 'wyr_id', 'INT NOT NULL PRIMARY KEY AUTO_INCREMENT  FIRST', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_wyr', 'wyr_id', 'INT NOT NULL PRIMARY KEY AUTO_INCREMENT  FIRST', @status, @message);

-- ---------------------------------------------------------
-- UPDATE DATA PROCEDURE
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS update_b25_to_b26_data;
DELIMITER $$
CREATE PROCEDURE update_b25_to_b26_data(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE original_COUNT INT;
    DECLARE temporary_COUNT INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
       SET OUT_message="Error SQL Exception";
    SET OUT_status=0;

    -- Incremental update table can contain duplicated lines
    -- In this case, we need to remove duplicated lines
    -- before to add the PRIMARY KEY
    -- Table incremental_update
    IF EXISTS (SELECT * FROM
            (SELECT db_update_name,count(*) AS cnt FROM incremental_update
            GROUP BY db_update_name) T
            WHERE cnt > 1)
    THEN
        DROP TABLE IF EXISTS tmp_incremental_update;
        CREATE TABLE tmp_incremental_update AS SELECT DISTINCT * FROM incremental_update;
        TRUNCATE TABLE incremental_update;
        INSERT INTO incremental_update SELECT * FROM tmp_incremental_update;
        DROP TABLE tmp_incremental_update;
        CALL update_log_message('REMOVE DUPLICATE KEYS','incremental_update','DONE','');
    END IF;

    -- Test Results tables can contain duplicated test results
    -- ie: more than one result per Test and Run
    -- In this case, we need to populate the new TestSeq column with a correct increment
    -- before to add the PRIMARY KEY

    -- Table ft_ptest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,ptest_info_id,run_id) AS cnt FROM ft_ptest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_ptest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE ft_ptest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,ptest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_ptest_results','DONE','');
        END;
    END IF;

    -- Table ft_ftest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,ftest_info_id,run_id) AS cnt FROM ft_ftest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_ftest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE ft_ftest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,ftest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_ftest_results','DONE','');
        END;
    END IF;

    -- Table ft_mptest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,mptest_info_id,run_id) AS cnt FROM ft_mptest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_mptest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE ft_mptest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,mptest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_mptest_results','DONE','');
        END;
    END IF;

    -- Table wt_ptest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,ptest_info_id,run_id) AS cnt FROM wt_ptest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_ptest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE wt_ptest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,ptest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_ptest_results','DONE','');
        END;
    END IF;

    -- Table wt_ftest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,ftest_info_id,run_id) AS cnt FROM wt_ftest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_ftest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE wt_ftest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,ftest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_ftest_results','DONE','');
        END;
    END IF;

    -- Table wt_mptest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,mptest_info_id,run_id) AS cnt FROM wt_mptest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_mptest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE wt_mptest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,mptest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_mptest_results','DONE','');
        END;
    END IF;

    -- Table et_ptest_results
    IF EXISTS(SELECT * FROM
            (SELECT count(distinct splitlot_id,ptest_info_id,run_id) AS cnt FROM et_ptest_results) T
            WHERE T.cnt < (SELECT count(*)  FROM et_ptest_results))
    THEN
        BEGIN
        SET @INC = 0;
        SET @RUN = 1;
        UPDATE et_ptest_results
            SET testseq=((CASE WHEN (run_id=@RUN) THEN @INC:=@INC+1 ELSE @INC:=@RUN:=run_id END)-run_id+1)
            ORDER BY splitlot_id,run_id,ptest_info_id;
        CALL update_log_message('REMOVE DUPLICATE KEYS','et_ptest_results','DONE','');
        END;
    END IF;

    -- Production Alarm table can contain duplicated Bin alarm due to multi YIELD tasks
    -- ie: more than one alarm per splitlot/cat/type
    -- In this case, we need to populate increment the item_no column with a correct increment
    -- before to add the PRIMARY KEY
    -- Table ft_prod_alarm
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,alarm_cat,alarm_type,item_no) AS cnt FROM ft_prod_alarm) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_prod_alarm))
    THEN
        BEGIN
        SET @INC=0;
        SET @ID=0;
        UPDATE ft_prod_alarm
            SET item_no = (CASE WHEN item_no=0 THEN
                                (CASE WHEN @ID <> splitlot_id THEN @INC:=@ID:=splitlot_id ELSE @INC:=@INC+1 END)-splitlot_id
                            ELSE item_no END)
            ORDER BY splitlot_id,alarm_cat,alarm_type,item_no,item_name;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_prod_alarm','DONE','');
        END;
    END IF;

    -- Table wt_prod_alarm
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,alarm_cat,alarm_type,item_no) AS cnt FROM wt_prod_alarm) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_prod_alarm))
    THEN
        BEGIN
        SET @INC=0;
        SET @ID=0;
        UPDATE wt_prod_alarm
            SET item_no = (CASE WHEN item_no=0 THEN
                                (CASE WHEN @ID <> splitlot_id THEN @INC:=@ID:=splitlot_id ELSE @INC:=@INC+1 END)-splitlot_id
                            ELSE item_no END)
            ORDER BY splitlot_id,alarm_cat,alarm_type,item_no,item_name;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_prod_alarm','DONE','');
        END;
    END IF;

    -- Table et_prod_alarm
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,alarm_cat,alarm_type,item_no) AS cnt FROM et_prod_alarm) T
            WHERE T.cnt < (SELECT count(*)  FROM et_prod_alarm))
    THEN
        BEGIN
        SET @INC=0;
        SET @ID=0;
        UPDATE et_prod_alarm
            SET item_no = (CASE WHEN item_no=0 THEN
                                (CASE WHEN @ID <> splitlot_id THEN @INC:=@ID:=splitlot_id ELSE @INC:=@INC+1 END)-splitlot_id
                            ELSE item_no END)
            ORDER BY splitlot_id,alarm_cat,alarm_type,item_no,item_name;
        CALL update_log_message('REMOVE DUPLICATE KEYS','et_prod_alarm','DONE','');
        END;
    END IF;

    -- Test Stats Summary table can contain duplicated lines due to multi TSR records
    -- In this case, we need to remove duplicated lines
    -- before to add the PRIMARY KEY
    -- Table wt_ptest_stats_summary
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,ptest_info_id,site_no) AS cnt FROM wt_ptest_stats_summary) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_ptest_stats_summary))
    THEN
        DROP TABLE IF EXISTS tmp_test_stats_summary;
        CREATE TABLE tmp_test_stats_summary AS SELECT DISTINCT * FROM wt_ptest_stats_summary;
        TRUNCATE TABLE wt_ptest_stats_summary;
        INSERT INTO wt_ptest_stats_summary SELECT * FROM tmp_test_stats_summary;
        DROP TABLE tmp_test_stats_summary;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_ptest_stats_summary','DONE','');
    END IF;

    -- Table wt_ftest_stats_summary
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,ftest_info_id,site_no) AS cnt FROM wt_ftest_stats_summary) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_ftest_stats_summary))
    THEN
        DROP TABLE IF EXISTS tmp_test_stats_summary;
        CREATE TABLE tmp_test_stats_summary AS SELECT DISTINCT * FROM wt_ftest_stats_summary;
        TRUNCATE TABLE wt_ftest_stats_summary;
        INSERT INTO wt_ftest_stats_summary SELECT * FROM tmp_test_stats_summary;
        DROP TABLE tmp_test_stats_summary;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_ftest_stats_summary','DONE','');
    END IF;

    -- Table wt_mptest_stats_summary
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,mptest_info_id,site_no) AS cnt FROM wt_mptest_stats_summary) T
            WHERE T.cnt < (SELECT count(*)  FROM wt_mptest_stats_summary))
    THEN
        DROP TABLE IF EXISTS tmp_test_stats_summary;
        CREATE TABLE tmp_test_stats_summary AS SELECT DISTINCT * FROM wt_mptest_stats_summary;
        TRUNCATE TABLE wt_mptest_stats_summary;
        INSERT INTO wt_mptest_stats_summary SELECT * FROM tmp_test_stats_summary;
        DROP TABLE tmp_test_stats_summary;
        CALL update_log_message('REMOVE DUPLICATE KEYS','wt_mptest_stats_summary','DONE','');
    END IF;

    -- Table ft_ptest_stats_summary
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,ptest_info_id,site_no) AS cnt FROM ft_ptest_stats_summary) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_ptest_stats_summary))
    THEN
        DROP TABLE IF EXISTS tmp_test_stats_summary;
        CREATE TABLE tmp_test_stats_summary AS SELECT DISTINCT * FROM ft_ptest_stats_summary;
        TRUNCATE TABLE ft_ptest_stats_summary;
        INSERT INTO ft_ptest_stats_summary SELECT * FROM tmp_test_stats_summary;
        DROP TABLE tmp_test_stats_summary;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_ptest_stats_summary','DONE','');
    END IF;

    -- Table ft_ftest_stats_summary
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,ftest_info_id,site_no) AS cnt FROM ft_ftest_stats_summary) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_ftest_stats_summary))
    THEN
        DROP TABLE IF EXISTS tmp_test_stats_summary;
        CREATE TABLE tmp_test_stats_summary AS SELECT DISTINCT * FROM ft_ftest_stats_summary;
        TRUNCATE TABLE ft_ftest_stats_summary;
        INSERT INTO ft_ftest_stats_summary SELECT * FROM tmp_test_stats_summary;
        DROP TABLE tmp_test_stats_summary;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_ftest_stats_summary','DONE','');
    END IF;

    -- Table ft_mptest_stats_summary
    IF EXISTS (SELECT * FROM
            (SELECT count(distinct splitlot_id,mptest_info_id,site_no) AS cnt FROM ft_mptest_stats_summary) T
            WHERE T.cnt < (SELECT count(*)  FROM ft_mptest_stats_summary))
    THEN
        DROP TABLE IF EXISTS tmp_test_stats_summary;
        CREATE TABLE tmp_test_stats_summary AS SELECT DISTINCT * FROM ft_mptest_stats_summary;
        TRUNCATE TABLE ft_mptest_stats_summary;
        INSERT INTO ft_mptest_stats_summary SELECT * FROM tmp_test_stats_summary;
        DROP TABLE tmp_test_stats_summary;
        CALL update_log_message('REMOVE DUPLICATE KEYS','ft_mptest_stats_summary','DONE','');
    END IF;

    SET OUT_status=1;

    END $$
DELIMITER ;

-- ---------------------------------------------------------
-- UPDATE DATA
-- ---------------------------------------------------------
CALL update_b25_to_b26_data(@status, @message);
DROP PROCEDURE IF EXISTS update_b25_to_b26_data;

-- ---------------------------------------------------------
-- ADD PRIMARY KEYS
-- ---------------------------------------------------------
CALL add_primary_key_to(Database(), 'global_info', 'db_version_build', @status, @message);
CALL add_primary_key_to(Database(), 'global_options', 'option_name', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ftest_info', 'splitlot_id,ftest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'et_ptest_results', 'splitlot_id,ptest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'wt_metadata_link', 'link_name', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ptest_limits', 'splitlot_id,ptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_sya_set', 'sya_id', @status, @message);
CALL add_primary_key_to(Database(), 'et_lot_sbin', 'lot_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_lot_hbin', 'lot_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_sbl', 'sya_id,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_splitlot', 'splitlot_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ftest_stats_samples', 'splitlot_id,ftest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_mptest_stats_summary', 'splitlot_id,mptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_product_hbin', 'product_name,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_ptest_info', 'splitlot_id,ptest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ftest_stats_samples', 'splitlot_id,ftest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_run', 'splitlot_id,run_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_prod_alarm', 'splitlot_id,alarm_cat,alarm_type,item_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_hbin_inter', 'lot_id,wafer_id,hbin_no,consolidation_name', @status, @message);
CALL add_primary_key_to(Database(), 'et_wafer_hbin', 'lot_id,wafer_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_run', 'splitlot_id,run_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_metadata_link', 'link_name', @status, @message);
CALL add_primary_key_to(Database(), 'wt_lot_sbin', 'lot_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_die_tracking', 'ft_tracking_lot_id,wt_tracking_lot_id,die_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_hbin', 'splitlot_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_mptest_limits', 'splitlot_id,mptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_consolidation_inter', 'lot_id,wafer_id,consolidation_name', @status, @message);
CALL add_primary_key_to(Database(), 'wt_sbl', 'sya_id,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_metadata_mapping', 'meta_name', @status, @message);
CALL add_primary_key_to(Database(), 'wt_metadata_mapping', 'meta_name', @status, @message);
CALL add_primary_key_to(Database(), 'et_splitlot', 'splitlot_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_sbin_stats_summary', 'splitlot_id,site_no,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_wafer_info', 'lot_id,wafer_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_info', 'lot_id,wafer_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_mptest_stats_samples', 'splitlot_id,mptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_hbin_stats_samples', 'splitlot_id,site_no,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_sbin_stats_samples', 'splitlot_id,site_no,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_sbin_stats_summary', 'splitlot_id,site_no,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_sbin_stats_samples', 'splitlot_id,site_no,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_mptest_stats_samples', 'splitlot_id,mptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_consolidation', 'lot_id,wafer_id,consolidation_name', @status, @message);
CALL add_primary_key_to(Database(), 'et_hbin', 'splitlot_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ptest_stats_samples', 'splitlot_id,ptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ftest_stats_summary', 'splitlot_id,ftest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_lot', 'lot_id', @status, @message);
CALL add_primary_key_to(Database(), 'incremental_update', 'db_update_name', @status, @message);
CALL add_primary_key_to(Database(), 'ft_sbl', 'sya_id,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ptest_limits', 'splitlot_id,ptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ftest_results', 'splitlot_id,ftest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'ft_run', 'splitlot_id,run_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_run_dietrace', 'splitlot_id,run_id,die_config_id,part_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_dietrace_config', 'splitlot_id,die_config_id,die_index', @status, @message);
CALL add_primary_key_to(Database(), 'wt_lot', 'lot_id,tracking_lot_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_mptest_results', 'splitlot_id,mptest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'et_ptest_stats', 'splitlot_id,ptest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_sya_set', 'sya_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_hbin_stats_summary', 'splitlot_id,site_no,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_dtr', 'splitlot_id,run_id,order_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ptest_results', 'splitlot_id,ptest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ptest_stats_summary', 'splitlot_id,ptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_wyr_format', 'site_name,column_id,data_type', @status, @message);
CALL add_primary_key_to(Database(), 'product', 'product_name', @status, @message);
CALL add_primary_key_to(Database(), 'ft_parts_stats_samples', 'splitlot_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_metadata_link', 'link_name', @status, @message);
CALL add_primary_key_to(Database(), 'wt_hbin_stats_summary', 'splitlot_id,site_no,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_lot_hbin', 'lot_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_mptest_info', 'splitlot_id,mptest_info_id,tnum,tpin_arrayindex', @status, @message);
CALL add_primary_key_to(Database(), 'ft_pin_map', 'splitlot_id,tpin_pmrindex,head_num,site_num', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_sbin_inter', 'lot_id,wafer_id,sbin_no,consolidation_name', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ftest_info', 'splitlot_id,ftest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_sbin', 'splitlot_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_parts_stats_samples', 'splitlot_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_lot_sbin', 'lot_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ftest_results', 'splitlot_id,ftest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ptest_info', 'splitlot_id,ptest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'file_host', 'file_host_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_product_sbin', 'product_name,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_dtr', 'splitlot_id,run_id,order_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_mptest_limits', 'splitlot_id,mptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ptest_results', 'splitlot_id,ptest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'et_product_hbin', 'product_name,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ptest_stats_summary', 'splitlot_id,ptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_mptest_stats_summary', 'splitlot_id,mptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_prod_alarm', 'splitlot_id,alarm_cat,alarm_type,item_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_hbin_stats_samples', 'splitlot_id,site_no,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_lot', 'lot_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wyr_format', 'site_name,column_id,data_type', @status, @message);
CALL add_primary_key_to(Database(), 'wt_product_hbin', 'product_name,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_ptest_info', 'splitlot_id,ptest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_hbin', 'lot_id,wafer_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_lot_hbin', 'lot_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_splitlot', 'splitlot_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_mptest_results', 'splitlot_id,mptest_info_id,run_id,testseq', @status, @message);
CALL add_primary_key_to(Database(), 'wt_wafer_sbin', 'lot_id,wafer_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ftest_stats_summary', 'splitlot_id,ftest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_wyr_format', 'site_name,column_id,data_type', @status, @message);
CALL add_primary_key_to(Database(), 'ft_product_sbin', 'product_name,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_sbin', 'splitlot_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_sbin', 'splitlot_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_mptest_info', 'splitlot_id,mptest_info_id', @status, @message);
CALL add_primary_key_to(Database(), 'wt_pin_map', 'splitlot_id,tpin_pmrindex,head_num,site_num', @status, @message);
CALL add_primary_key_to(Database(), 'wt_parts_stats_summary', 'splitlot_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_prod_alarm', 'splitlot_id,alarm_cat,alarm_type,item_no', @status, @message);
CALL add_primary_key_to(Database(), 'ft_hbin', 'splitlot_id,hbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'wt_ptest_stats_samples', 'splitlot_id,ptest_info_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_sya_set', 'sya_id', @status, @message);
CALL add_primary_key_to(Database(), 'et_dtr', 'splitlot_id,run_id,order_id', @status, @message);
CALL add_primary_key_to(Database(), 'et_product_sbin', 'product_name,bin_no', @status, @message);
CALL add_primary_key_to(Database(), 'global_files', 'file_id', @status, @message);
CALL add_primary_key_to(Database(), 'ft_parts_stats_summary', 'splitlot_id,site_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_metadata_mapping', 'meta_name', @status, @message);
CALL add_primary_key_to(Database(), 'et_wafer_sbin', 'lot_id,wafer_id,sbin_no', @status, @message);
CALL add_primary_key_to(Database(), 'et_test_conditions', 'splitlot_id,test_info_id,test_type', @status, @message);
CALL add_primary_key_to(Database(), 'ft_test_conditions', 'splitlot_id,test_info_id,test_type', @status, @message);
CALL add_primary_key_to(Database(), 'wt_test_conditions', 'splitlot_id,test_info_id,test_type', @status, @message);


-- ---------------------------------------------------------
-- ADD COLUMNS FOR BIN_TYPE
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'wt_sya_set', 'bin_type', 'TINYINT(1) NULL  AFTER rule_name', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_sya_set', 'bin_type', 'TINYINT(1) NULL  AFTER rule_name', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_sya_set', 'bin_type', 'TINYINT(1) NULL  AFTER rule_name', @status, @message);


-- ---------------------------------------------------------
-- ADD COLUMNS PART STATUS
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'et_run', 'part_status', 'char(1) DEFAULT NULL AFTER part_y', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'part_status', 'char(1) DEFAULT NULL AFTER part_y', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'part_status', 'char(1) DEFAULT NULL AFTER part_y', @status, @message);


-- ---------------------------------------------------------
-- CHANGE DEFAULT IN DTR RUN_ID
-- TODO REMOVE THIS FUNCTION BUT ONLY FOR UPDATE NOT FOR CREATION
-- ---------------------------------------------------------
CALL alter_column(Database(), 'ft_dtr', 'run_id', 'SET DEFAULT 0', @status, @message);
CALL alter_column(Database(), 'wt_dtr', 'run_id', 'SET DEFAULT 0', @status, @message);
CALL alter_column(Database(), 'et_dtr', 'run_id', 'SET DEFAULT 0', @status, @message);
CALL change_column(Database(), 'global_files', 'file_content', 'mediumtext NOT NULL', @status, @message);


-- ---------------------------------------------------------
-- UPDATE field tpin_pmrindex change size
-- ---------------------------------------------------------
CALL change_column(Database(), 'wt_mptest_results', 'tpin_pmrindex', 'int(10) NOT NULL', @status, @message);
CALL change_column(Database(), 'ft_mptest_results', 'tpin_pmrindex', 'int(10) NOT NULL', @status, @message);


-- ---------------------------------------------------------
-- CREATE PINMAP TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS ft_pin_map (
  splitlot_id int(10) unsigned NOT NULL,
  tpin_pmrindex int(10) NOT NULL,
  chan_typ smallint(5) unsigned DEFAULT '0',
  chan_nam varchar(255) DEFAULT '',
  phy_nam varchar(255) DEFAULT '',
  log_nam varchar(255) DEFAULT '',
  head_num tinyint(4) unsigned DEFAULT '1',
  site_num tinyint(4) unsigned DEFAULT '1',
  PRIMARY KEY (splitlot_id,tpin_pmrindex,head_num,site_num)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 ;
CALL update_log_message('CREATE TABLE','ft_pin_map','DONE',null);

-- ---------------------------------------------------------
-- CREATE PINMAP TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS wt_pin_map (
  splitlot_id int(10) unsigned NOT NULL,
  tpin_pmrindex int(10) NOT NULL,
  chan_typ smallint(5) unsigned DEFAULT '0',
  chan_nam varchar(255) DEFAULT '',
  phy_nam varchar(255) DEFAULT '',
  log_nam varchar(255) DEFAULT '',
  head_num tinyint(4) unsigned DEFAULT '1',
  site_num tinyint(4) unsigned DEFAULT '1',
  PRIMARY KEY (splitlot_id,tpin_pmrindex,head_num,site_num)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 ;
CALL update_log_message('CREATE TABLE','wt_pin_map','DONE',null);

-- ---------------------------------------------------------
-- CREATE SDR TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS et_sdr (
splitlot_id int(10) unsigned NOT NULL DEFAULT '0',
site_grp smallint unsigned NOT NULL DEFAULT '0',
site_index smallint unsigned NOT NULL DEFAULT '0',
site_no smallint unsigned NOT NULL DEFAULT '0',
hand_typ varchar(255) DEFAULT NULL,
hand_id varchar(255) DEFAULT NULL,
card_typ varchar(255) DEFAULT NULL,
card_id varchar(255) DEFAULT NULL,
load_typ varchar(255) DEFAULT NULL,
load_id varchar(255) DEFAULT NULL,
dib_typ varchar(255) DEFAULT NULL,
dib_id varchar(255) DEFAULT NULL,
cabl_typ varchar(255) DEFAULT NULL,
cabl_id varchar(255) DEFAULT NULL,
cont_typ varchar(255) DEFAULT NULL,
cont_id varchar(255) DEFAULT NULL,
lasr_typ varchar(255) DEFAULT NULL,
lasr_id varchar(255) DEFAULT NULL,
extr_typ varchar(255) DEFAULT NULL,
extr_id varchar(255) DEFAULT NULL,
PRIMARY KEY (splitlot_id, site_grp, site_no)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','et_sdr','DONE',null);

-- ---------------------------------------------------------
-- CREATE SDR TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS ft_sdr (
splitlot_id int(10) unsigned NOT NULL DEFAULT '0',
site_grp smallint unsigned NOT NULL DEFAULT '0',
site_index smallint unsigned NOT NULL DEFAULT '0',
site_no smallint unsigned NOT NULL DEFAULT '0',
hand_typ varchar(255) DEFAULT NULL,
hand_id varchar(255) DEFAULT NULL,
card_typ varchar(255) DEFAULT NULL,
card_id varchar(255) DEFAULT NULL,
load_typ varchar(255) DEFAULT NULL,
load_id varchar(255) DEFAULT NULL,
dib_typ varchar(255) DEFAULT NULL,
dib_id varchar(255) DEFAULT NULL,
cabl_typ varchar(255) DEFAULT NULL,
cabl_id varchar(255) DEFAULT NULL,
cont_typ varchar(255) DEFAULT NULL,
cont_id varchar(255) DEFAULT NULL,
lasr_typ varchar(255) DEFAULT NULL,
lasr_id varchar(255) DEFAULT NULL,
extr_typ varchar(255) DEFAULT NULL,
extr_id varchar(255) DEFAULT NULL,
PRIMARY KEY (splitlot_id, site_grp, site_no)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','ft_sdr','DONE',null);


-- ---------------------------------------------------------
-- CREATE SDR TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS wt_sdr (
splitlot_id int(10) unsigned NOT NULL DEFAULT '0',
site_grp smallint unsigned NOT NULL DEFAULT '0',
site_index smallint unsigned NOT NULL DEFAULT '0',
site_no smallint unsigned NOT NULL DEFAULT '0',
hand_typ varchar(255) DEFAULT NULL,
hand_id varchar(255) DEFAULT NULL,
card_typ varchar(255) DEFAULT NULL,
card_id varchar(255) DEFAULT NULL,
load_typ varchar(255) DEFAULT NULL,
load_id varchar(255) DEFAULT NULL,
dib_typ varchar(255) DEFAULT NULL,
dib_id varchar(255) DEFAULT NULL,
cabl_typ varchar(255) DEFAULT NULL,
cabl_id varchar(255) DEFAULT NULL,
cont_typ varchar(255) DEFAULT NULL,
cont_id varchar(255) DEFAULT NULL,
lasr_typ varchar(255) DEFAULT NULL,
lasr_id varchar(255) DEFAULT NULL,
extr_typ varchar(255) DEFAULT NULL,
extr_id varchar(255) DEFAULT NULL,
PRIMARY KEY (splitlot_id, site_grp, site_no)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','wt_sdr','DONE',null);

-- ---------------------------------------------------------
-- CREATE METADATA TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS et_lot_metadata (
    lot_id varchar(255) NOT NULL,
    product_name varchar(255) NOT NULL,
    PRIMARY KEY (lot_id, product_name)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','et_lot_metadata','DONE',null);

-- ---------------------------------------------------------
-- CREATE METADATA TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS et_splitlot_metadata (
  splitlot_id int(10) unsigned NOT NULL DEFAULT '0',
    PRIMARY KEY (splitlot_id)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','et_splitlot_metadata','DONE',null);

-- ---------------------------------------------------------
-- CREATE METADATA TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS ft_lot_metadata (
    lot_id varchar(255) NOT NULL,
    product_name varchar(255) NOT NULL,
    PRIMARY KEY (lot_id, product_name)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','ft_lot_metadata','DONE',null);

-- ---------------------------------------------------------
-- CREATE METADATA TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS ft_splitlot_metadata (
  splitlot_id int(10) unsigned NOT NULL DEFAULT '0',
    PRIMARY KEY (splitlot_id)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','ft_splitlot_metadata','DONE',null);

-- ---------------------------------------------------------
-- CREATE METADATA TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS wt_lot_metadata (
    lot_id varchar(255) NOT NULL,
    product_name varchar(255) NOT NULL,
    PRIMARY KEY (lot_id, product_name)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','wt_lot_metadata','DONE',null);

-- ---------------------------------------------------------
-- CREATE METADATA TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS wt_splitlot_metadata (
  splitlot_id int(10) unsigned NOT NULL DEFAULT '0',
    PRIMARY KEY (splitlot_id)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','wt_splitlot_metadata','DONE',null);

-- ---------------------------------------------------------
-- CREATE TOKEN TABLE
-- ---------------------------------------------------------
CREATE TABLE IF NOT EXISTS token (
  start_time datetime NOT NULL,
  name varchar(256) NOT NULL,
  key_value varchar(512) NOT NULL,
  sql_id int(10) NOT NULL,
  PRIMARY KEY (name,key_value)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CALL update_log_message('CREATE TABLE','token','DONE',null);

-- ---------------------------------------------------------
-- NEW xx_insertion_preprocessing and xx_check_data_integrity stored procedures
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS et_insertion_preprocessing;
DELIMITER $$
CREATE PROCEDURE et_insertion_preprocessing(
IN Splitlot INT, -- SplitlotId of the splitlot to be pre-processed
OUT Message VARCHAR(1024), -- Return the Error message in case the pre-processing fails
OUT Status INT -- Status for the insertion (0=FAIL , 1=PASS, 2=DELAY)
)
BEGIN

SELECT 'Success' INTO Message From dual;
SELECT 1 INTO Status FROM dual;

-- The call to the following stored procedure should be last in this stored procedure.
-- Any customisation should be done above.
CALL et_check_data_integrity(Splitlot, Message, Status);

END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS et_check_data_integrity;
DELIMITER $$
CREATE PROCEDURE et_check_data_integrity(
IN Splitlot INT, -- SplitlotId of the splitlot to be checked
OUT Message VARCHAR(1024), -- Return the Error message in case the check fails
OUT Status INT -- Status for the insertion (0=FAIL , 1=PASS, 2=DELAY)
)
BEGIN

-- !!!! DO NOT MODIFY THIS STORED PROCEDURE !!!!
-- !!!! IT CAN POTENTIALLY BE DROPPED/MODIFIED BY TDR UPDATE SCRIPTS !!!!
-- !!!! ANY MODIFICATION COULD BE LOST DURING FUTURE TDR UPDATES !!!!

SELECT 'Success' INTO Message From dual;
SELECT 1 INTO Status FROM dual;

END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS ft_insertion_preprocessing;
DELIMITER $$
CREATE PROCEDURE ft_insertion_preprocessing(
IN Splitlot INT, -- SplitlotId of the splitlot to be pre-processed
OUT Message VARCHAR(1024), -- Return the Error message in case the pre-processing fails
OUT Status INT -- Status for the insertion (0=FAIL , 1=PASS, 2=DELAY)
)
BEGIN

SELECT 'Success' INTO Message From dual;
SELECT 1 INTO Status FROM dual;

-- The call to the following stored procedure should be last in this stored procedure.
-- Any customisation should be done above.
CALL ft_check_data_integrity(Splitlot, Message, Status);

END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS ft_check_data_integrity;
DELIMITER $$
CREATE PROCEDURE ft_check_data_integrity(
IN Splitlot INT, -- SplitlotId of the splitlot to be checked
OUT Message VARCHAR(1024), -- Return the Error message in case the check fails
OUT Status INT -- Status for the insertion (0=FAIL , 1=PASS, 2=DELAY)
)
BEGIN

-- !!!! DO NOT MODIFY THIS STORED PROCEDURE !!!!
-- !!!! IT CAN POTENTIALLY BE DROPPED/MODIFIED BY TDR UPDATE SCRIPTS !!!!
-- !!!! ANY MODIFICATION COULD BE LOST DURING FUTURE TDR UPDATES !!!!

    DECLARE finished            INT UNSIGNED DEFAULT 0;
    DECLARE BackgroundTableName VARCHAR(1024);
    DECLARE OriginalTableName   VARCHAR(1024);
    DECLARE LotID               VARCHAR(1024);
    DECLARE SublotID            VARCHAR(1024);
    DECLARE SqlQuery            TEXT;
    DECLARE MinSplitlotID       INT(10);
    DECLARE SplitlotCount       INT;
    DECLARE TableCount          INT;

    DECLARE c1 CURSOR FOR
        SELECT table_name
        FROM information_schema.tables T
        WHERE TABLE_SCHEMA=Database() AND TABLE_NAME like 'ft_%_background'AND TABLE_NAME not like 'ft_%test_results_background';

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET finished = 1;

    SELECT 'Success' INTO Message From dual;
    SELECT 1 INTO Status FROM dual;

    -- If no more background tables other than '%test_results_background', OK
    SELECT count(table_name)
    FROM information_schema.tables T
    WHERE TABLE_SCHEMA=Database() AND TABLE_NAME like 'ft_%_background' AND TABLE_NAME not like 'ft_%test_results_background'
    INTO TableCount;

    -- Check if any tables found
    IF TableCount > 0 THEN

        insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'ft_check_data_integrity', concat('background tables to check=',TableCount));

        -- Get Lot, wafer_id
        SELECT lot_id, sublot_id from ft_splitlot where splitlot_id=Splitlot INTO LotID, SublotID;

        -- Get min splitlots for this lot, wafer
        SELECT min(splitlot_id) FROM ft_splitlot where lot_id=LotID AND sublot_id=SublotID AND valid_splitlot='Y' AND prod_data='Y' INTO MinSplitlotID;

        -- Check if any splitlot found
        if MinSplitlotID is not NULL THEN
            insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'ft_check_data_integrity', concat('min(splitlot_id) for lot (', LotID, '), sublot (', SublotID, ')=', MinSplitlotID));

            -- Loop over list of background tables other than '%test_results_background'
            SET finished=0;
            OPEN c1;
            cursor_loop:REPEAT
                FETCH c1 INTO BackgroundTableName;
                IF NOT finished THEN
                    -- Check if min(splitlot_id) is in the corresponding TDR table
                    -- If not, DELAY
                    SELECT TRIM(TRAILING '_background' FROM BackgroundTableName) INTO OriginalTableName;

                    SET @Result = 1;
                    SELECT CONCAT("SELECT count(splitlot_id) FROM ", OriginalTableName, " WHERE splitlot_id=", MinSplitlotID, " INTO @Result") INTO @Query;
                    PREPARE SqlQuery FROM @Query;
                    EXECUTE SqlQuery;
                    SELECT @Result INTO SplitlotCount;

                    IF SplitlotCount = 0 THEN
                        insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'ft_check_data_integrity', concat('table ', OriginalTableName, ' has NO data for splitlot ', MinSplitlotID));
                        SELECT concat('ft_check_data_integrity: not all data for this lot/wafer yet transferred from background table ', BackgroundTableName) INTO Message From dual;
                        SELECT 2 INTO Status FROM dual;
                        LEAVE cursor_loop;
                    ELSE
                        insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'ft_check_data_integrity', concat('table ', OriginalTableName, ' has data for splitlot ', MinSplitlotID));
                    END IF;
                END IF;
            UNTIL finished
            END REPEAT cursor_loop;
            CLOSE c1;
        END IF;
    END IF;

END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS wt_insertion_preprocessing;
DELIMITER $$
CREATE PROCEDURE wt_insertion_preprocessing(
IN Splitlot INT, -- SplitlotId of the splitlot to be pre-processed
OUT Message VARCHAR(1024), -- Return the Error message in case the pre-processing fails
OUT Status INT -- Status for the insertion (0=FAIL , 1=PASS, 2=DELAY)
)
BEGIN

SELECT 'Success' INTO Message From dual;
SELECT 1 INTO Status FROM dual;

-- The call to the following stored procedure should be last in this stored procedure.
-- Any customisation should be done above.
CALL wt_check_data_integrity(Splitlot, Message, Status);

END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS wt_check_data_integrity;
DELIMITER $$
CREATE PROCEDURE wt_check_data_integrity(
IN Splitlot INT, -- SplitlotId of the splitlot to be checked
OUT Message VARCHAR(1024), -- Return the Error message in case the check fails
OUT Status INT -- Status for the insertion (0=FAIL , 1=PASS, 2=DELAY)
)
BEGIN

-- !!!! DO NOT MODIFY THIS STORED PROCEDURE !!!!
-- !!!! IT CAN POTENTIALLY BE DROPPED/MODIFIED BY TDR UPDATE SCRIPTS !!!!
-- !!!! ANY MODIFICATION COULD BE LOST DURING FUTURE TDR UPDATES !!!!

    DECLARE finished            INT UNSIGNED DEFAULT 0;
    DECLARE BackgroundTableName VARCHAR(1024);
    DECLARE OriginalTableName   VARCHAR(1024);
    DECLARE LotID               VARCHAR(1024);
    DECLARE WaferID             VARCHAR(1024);
    DECLARE SqlQuery            TEXT;
    DECLARE MinSplitlotID       INT(10);
    DECLARE SplitlotCount       INT;
    DECLARE TableCount          INT;

    DECLARE c1 CURSOR FOR
        SELECT table_name
        FROM information_schema.tables T
        WHERE TABLE_SCHEMA=Database() AND TABLE_NAME like 'wt_%_background'AND TABLE_NAME not like 'wt_%test_results_background';

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET finished = 1;

    SELECT 'Success' INTO Message From dual;
    SELECT 1 INTO Status FROM dual;

    -- If no more background tables other than '%test_results_background', OK
    SELECT count(table_name)
    FROM information_schema.tables T
    WHERE TABLE_SCHEMA=Database() AND TABLE_NAME like 'wt_%_background' AND TABLE_NAME not like 'wt_%test_results_background'
    INTO TableCount;

    -- Check if any tables found
    IF TableCount > 0 THEN

        insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'wt_check_data_integrity', concat('background tables to check=',TableCount));

        -- Get Lot, wafer_id
        SELECT lot_id, wafer_id from wt_splitlot where splitlot_id=Splitlot INTO LotID, WaferID;

        -- Get min splitlots for this lot, wafer
        SELECT min(splitlot_id) FROM wt_splitlot where lot_id=LotID AND wafer_id=WaferID AND valid_splitlot='Y' AND prod_data='Y' INTO MinSplitlotID;

        -- Check if any splitlot found
        if MinSplitlotID is not NULL THEN
            insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'wt_check_data_integrity', concat('min(splitlot_id) for lot (', LotID, '), wafer (', WaferID, ')=', MinSplitlotID));

            -- Loop over list of background tables other than '%test_results_background'
            SET finished=0;
            OPEN c1;
            cursor_loop:REPEAT
                FETCH c1 INTO BackgroundTableName;
                IF NOT finished THEN
                    -- Check if min(splitlot_id) is in the corresponding TDR table
                    -- If not, DELAY
                    SELECT TRIM(TRAILING '_background' FROM BackgroundTableName) INTO OriginalTableName;

                    SET @Result = 1;
                    SELECT CONCAT("SELECT count(splitlot_id) FROM ", OriginalTableName, " WHERE splitlot_id=", MinSplitlotID, " INTO @Result") INTO @Query;
                    PREPARE SqlQuery FROM @Query;
                    EXECUTE SqlQuery;
                    SELECT @Result INTO SplitlotCount;

                    IF SplitlotCount = 0 THEN
                        insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'wt_check_data_integrity', concat('table ', OriginalTableName, ' has NO data for splitlot ', MinSplitlotID));
                        SELECT concat('wt_check_data_integrity: not all data for this lot/wafer yet transferred from background table ', BackgroundTableName) INTO Message From dual;
                        SELECT 2 INTO Status FROM dual;
                        LEAVE cursor_loop;
                    ELSE
                        insert into gexdb_log(log_date, log_type, log_string) values(NOW(), 'wt_check_data_integrity', concat('table ', OriginalTableName, ' has data for splitlot ', MinSplitlotID));
                    END IF;
                END IF;
            UNTIL finished
            END REPEAT cursor_loop;
            CLOSE c1;
        END IF;
    END IF;

END $$
DELIMITER ;


-- ---------------------------------------------------------
-- INCREMENTAL TDR UPDATE
-- ---------------------------------------------------------
-- Finalize the first step of the Incremental TDR update
-- Transfer N splitlots

-- CALL background_transfer_hot_copy(@status, @message);

-- ---------------------------------------------------------
-- STOP UPDATE
-- ---------------------------------------------------------
CALL stop_update(@status, @message);




