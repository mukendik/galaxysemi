-- ---------------------------------------------------------
-- DO NOT EDIT THIS FILE UNLESS:
-- o To customize the update
-- o To execute it manually
-- ---------------------------------------------------------


-- ---------------------------------------------------------
-- Caution messages below are not commented to make sure that
-- scripts are in the right state before to be ran manually
-- ---------------------------------------------------------
CAUTION: when running manually that script make sure to uncomment the line below to specify a working database
-- use database_name_xx;
CAUTION: when running manually that script make sure to comment each lines: "DECLARE EXIT HANDLER FOR SQLEXCEPTION" (if it exists) to be sure to catch all errors


-- ---------------------------------------------------------
-- TDR UPDATE HISTORY AND STATE
-- create and populate using start_update() and stop_update()
-- ---------------------------------------------------------

-- table TDR_UPDATE_HISTORY contains the current update
-- an update can be the execution of multi bxx_to_byy until the supported YM version
CREATE TABLE IF NOT EXISTS tdr_update_history (
  update_id INT NOT NULL AUTO_INCREMENT,
  update_from INT NOT NULL,
  update_to INT NULL,
  start_time DATETIME NULL,
  end_time DATETIME NULL,
  status VARCHAR(45) NULL,      -- TODO, IN PROGRESS, FAIL, DONE
  PRIMARY KEY (update_id)
);

-- table tdr_update_tables_state contains all tables status from the TDR before the update
CREATE TABLE IF NOT EXISTS  tdr_update_tables_state (
  update_id INT NOT NULL,
  table_name VARCHAR(65) NOT NULL,
  table_type VARCHAR(65) NOT NULL,
  engine VARCHAR(65) NOT NULL,
  version INT NOT NULL,
  row_format VARCHAR(65) NOT NULL,
  auto_increment INT NULL,
  table_collation VARCHAR(65) NOT NULL,
  table_rows BIGINT NULL,
  create_time DATETIME NULL,
  PRIMARY KEY (update_id, table_name)
);
CALL modify_column(Database(), 'tdr_update_tables_state', 'table_rows', 'BIGINT NULL', @status, @message);


-- table tdr_update_partitions_state contains all partition status from the TDR
CREATE TABLE IF NOT EXISTS  tdr_update_partitions_state (
  update_id INT NOT NULL,
  table_name VARCHAR(65) NOT NULL,
  partition_name VARCHAR(65) NOT NULL,
  partition_ordinal_position INT NOT NULL,
  partition_method VARCHAR(65) NOT NULL,
  partition_expression VARCHAR(255) NOT NULL,
  min_index INT NOT NULL,
  max_index INT NOT NULL,
  partition_rows BIGINT NULL,
  PRIMARY KEY (update_id, table_name,partition_name)
);
CALL modify_column(Database(), 'tdr_update_partitions_state', 'partition_rows', 'BIGINT NULL', @status, @message);


-- table tdr_update_history_logs contains the logs generated by the update process
-- DROP TABLE IF EXISTS update_logs;
CREATE TABLE IF NOT EXISTS  tdr_update_logs (
  log_id INT NOT NULL AUTO_INCREMENT,
  update_id INT NOT NULL,
  build_version INT NULL,   -- build version where the update is mandatory
  date DATETIME NULL,
  action VARCHAR(255) NULL, -- ADD COLUMN, ADD PK
  description TEXT NULL,    -- query
  status VARCHAR(45) NULL,  -- IN PROGRESS, FAIL, DONE
  message TEXT NULL,        -- ERROR/SUCCESS MESSAGE
  PRIMARY KEY (log_id)
);


-- LOG PROCEDURES

DROP PROCEDURE IF EXISTS update_log_message;
DELIMITER $$
CREATE PROCEDURE update_log_message(
    IN IN_action TEXT,
    IN IN_description TEXT,
    IN IN_status VARCHAR(45),
    IN IN_message TEXT)
BEGIN
    CALL tdr_update_id(@current_update_id);
    CALL tdr_build_version(@current_build_version);

    IF (@current_update_id IS NULL)
    THEN
        SELECT 1 INTO @current_update_id;
    END IF;

    INSERT INTO tdr_update_logs(update_id,build_version,date,action,description,status,message)
    VALUES(@current_update_id,@current_build_version,now(),IN_action,IN_description,IN_status,IN_message);
    SELECT * FROM tdr_update_logs ORDER BY log_id DESC LIMIT 1;

END $$
DELIMITER ;

-- ---------------------------------------------------------
-- TDR FUNCTIONS
-- ---------------------------------------------------------

-- Return the current update_id
DROP FUNCTION IF EXISTS tdr_update_id;
DROP PROCEDURE IF EXISTS tdr_update_id;
DELIMITER $$
CREATE PROCEDURE tdr_update_id(OUT OUT_update_id INT)
BEGIN
  SELECT MAX(update_id) FROM tdr_update_history INTO OUT_update_id;
END;
$$
DELIMITER ;

-- Return the current build version
DROP FUNCTION IF EXISTS tdr_build_version;
DROP PROCEDURE IF EXISTS tdr_build_version;
DELIMITER $$
CREATE PROCEDURE tdr_build_version(OUT OUT_build_version INT)
BEGIN
  CALL tdr_update_id(@current_update_id);
  SELECT update_to FROM tdr_update_history WHERE update_id=@current_update_id INTO OUT_build_version;
END;
$$
DELIMITER ;

-- ---------------------------------------------------------
-- BACKGROUND INCREMENTAL TRANSFER TDR UPDATE
-- ---------------------------------------------------------
-- table background_transfer_history
-- use only when need an incremental background update
CREATE TABLE IF NOT EXISTS background_transfer_history (
  update_id INT NOT NULL,           -- reference of the current update_history
  min_index INT UNSIGNED NULL,      -- min of the min xx_splitlot tables
  max_index INT UNSIGNED NULL,      -- max of the max xx_splitlot tables
  current_index INT UNSIGNED NULL,  -- start from this index to min_index
  current_sid INT UNSIGNED NULL,    -- SESSION ID running
  start_time DATETIME NULL,         -- start of the incremental background update
  end_time DATETIME NULL,           -- end of the incremental background update
  status VARCHAR(45) NULL,          -- TODO, IN PROGRESS, FAIL, DONE
  PRIMARY KEY (update_id)
);

-- table TDR_UPDATE_SETTINGS contains the current settings
CREATE TABLE IF NOT EXISTS background_transfer_settings (
  update_id INT NOT NULL,
  setting_key VARCHAR(65) NOT NULL,
  setting_value VARCHAR(65) NOT NULL,
  PRIMARY KEY (update_id,setting_key,setting_value)
);

-- table background_transferTABLES contains the list of tables to manage
CREATE TABLE IF NOT EXISTS  background_transfer_tables (
  update_id INT NOT NULL,
  table_name VARCHAR(65) NOT NULL,
  min_index INT NOT NULL,
  max_index INT NOT NULL,
  current_index INT NULL,
  current_sid INT UNSIGNED NULL,    -- SESSION ID running
  start_time DATETIME NULL,
  end_time DATETIME NULL,
  status VARCHAR(45) NULL,
  PRIMARY KEY (update_id, table_name)
);

-- table background_transferPARTITIONS contains the list of partitions to manage
CREATE TABLE IF NOT EXISTS background_transfer_partitions (
  update_id INT NOT NULL,
  table_name VARCHAR(65) NOT NULL,
  partition_name VARCHAR(65) NOT NULL,
  min_index INT NOT NULL,
  max_index INT NOT NULL,
  current_index INT NULL,
  current_sid INT UNSIGNED NULL,    -- SESSION ID running
  start_time DATETIME NULL,
  end_time DATETIME NULL,
  status VARCHAR(45) NULL,
  PRIMARY KEY (update_id, table_name, partition_name)
);
CALL add_column_if_not_exists(Database(), 'background_transfer_partitions', 'current_index', 'INT NULL AFTER `max_index`', @status, @message);
CALL add_column_if_not_exists(Database(), 'background_transfer_partitions', 'current_sid', 'INT NULL AFTER `max_index`', @status, @message);

-- table background_transfer_actions contains the list of partitions to manage
CREATE TABLE IF NOT EXISTS background_transfer_tables_description (
  update_id INT NOT NULL,
  build_version INT NOT NULL,           -- build version where the background is mandatory
  table_name VARCHAR(65) NOT NULL,
  ordinal_position INT NULL,
  column_name VARCHAR(65) NOT NULL,
  expression TEXT NULL,
  PRIMARY KEY (update_id, table_name, column_name)
);

-- table background_transfer_logs contains the logs generated by the update process
CREATE TABLE IF NOT EXISTS  background_transfer_logs (
  log_id INT NOT NULL AUTO_INCREMENT,
  update_id INT NOT NULL,
  sid INT NOT NULL,
  date DATETIME NULL,
  action VARCHAR(255) NULL, -- ADD COLUMN, ADD PK
  description TEXT NULL,    -- query
  status VARCHAR(45) NULL,  -- IN PROGRESS, FAIL, DONE
  message TEXT NULL,        -- ERROR/SUCCESS MESSAGE
  PRIMARY KEY (log_id)
);
CALL add_column_if_not_exists(Database(), 'background_transfer_logs', 'sid', 'INT NOT NULL AFTER `update_id`', @status, @message);


-- Return the current active background update_id
DROP PROCEDURE IF EXISTS background_update_id;
DELIMITER $$
CREATE PROCEDURE background_update_id(OUT OUT_update_id INT)
BEGIN
  -- Take the current actif background process
  -- It is possible to have several background processes to do
  -- Take the first one to do
  SELECT MIN(update_id) FROM background_transfer_history WHERE status<>'DONE' INTO OUT_update_id;
  IF (OUT_update_id IS NULL) THEN
    SELECT MAX(update_id) FROM background_transfer_history INTO OUT_update_id;
  END IF;
END;
$$
DELIMITER ;

-- ---------------------------------------------------------
-- LOG PROCEDURES
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS background_transfer_log_message;
DELIMITER $$
CREATE PROCEDURE background_transfer_log_message(
    IN IN_update_id INT,
    IN IN_action TEXT,
    IN IN_description TEXT,
    IN IN_status VARCHAR(45),
    IN IN_message TEXT)
BEGIN
    IF (IN_update_id IS NOT NULL) THEN
      INSERT INTO  background_transfer_logs(update_id,sid,date,action,description,status,message)
            VALUES(IN_update_id,connection_id(),now(),IN_action,IN_description,IN_status,IN_message);
      -- Display the log
      SELECT * FROM  background_transfer_logs ORDER BY log_id DESC LIMIT 1;
    END IF;
END $$
DELIMITER ;

-- ---------------------------------------------------------
-- UPDATE PROCEDURE/FUNCTION
-- ---------------------------------------------------------

CALL add_column_if_not_exists(Database(), 'global_info', 'db_status', 'varchar(255) DEFAULT NULL COMMENT \'current state of the database, stores the tasks that needs to be done if the database is not ready\' AFTER `db_version_build`', @status, @message);

DROP PROCEDURE IF EXISTS start_global_tdr_update;
DELIMITER $$
CREATE PROCEDURE start_global_tdr_update(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE last_log_id INT;
    DECLARE old_update_id INT;
    DECLARE new_db_status TEXT;
    DECLARE current_version_build SMALLINT(5) DEFAULT 0;
    DECLARE current_status TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
        IF EXISTS(SELECT log_id FROM tdr_update_logs WHERE log_id>last_log_id AND status='FAIL')
        THEN
            SELECT CONCAT(date,' - ',action,' - ',description,' - ',status,' - ',message) FROM tdr_update_logs WHERE log_id>last_log_id  AND status='FAIL'
            INTO OUT_message;
        END IF;
    END;
    SET OUT_status=0;

    SELECT max(log_id) FROM tdr_update_logs INTO last_log_id;
    SELECT db_version_build, db_status FROM global_info INTO current_version_build, current_status;

    -- if the update was stopped before the end
    -- we need to restart at the begining of this update
    IF (INSTR(current_status,'UPDATING_DATABASE')>0) THEN
        SET current_version_build = current_version_build-1;
    END IF;

    -- The first step is to initialize or retrieve the @current_update_id
    IF EXISTS(SELECT update_id FROM tdr_update_history WHERE status<>'DONE')
    THEN
        -- Update in progress
        -- use it
        SET OUT_status=1;
    ELSE

        -- Check if have a background transfer event is actived
        CALL background_transfer_event_is_activated(@background_event_enabled);
        IF (@background_event_enabled)
        THEN
            CALL update_log_message('UPDATE TDR','CHECK BACKGROUND PROCESS','FAIL','Background transfer event is running.\n Please stop it before to start the update.');
            SELECT current_version_build FROM ERROR_BACKGROUND_TRANSFER_RUNNING;
        END IF;

        -- This is a new update stage
        -- initialize tdr_update_history
        INSERT INTO tdr_update_history (update_from,start_time,status)
        VALUES (current_version_build,now(),'TODO');

        CALL tdr_update_id(@current_update_id);

        -- Initialize tables and partitions description
        -- INSERT IGNORE TO NOT HAVE DUPLICATE LINE
        INSERT IGNORE INTO tdr_update_tables_state (update_id,table_name,table_type,engine,version,row_format,auto_increment,table_collation,table_rows,create_time)
        SELECT @current_update_id, T.table_name, T.table_type,T.engine,T.version,T.row_format,T.auto_increment,T.table_collation,T.table_rows,T.create_time
        FROM information_schema.tables T WHERE TABLE_SCHEMA=Database() AND TABLE_TYPE='BASE TABLE'
        ORDER BY T.table_name;

        -- INSERT IGNORE TO NOT HAVE DUPLICATE LINE
        INSERT IGNORE INTO tdr_update_partitions_state (update_id,table_name,partition_name,partition_ordinal_position,partition_method,partition_expression,min_index,max_index,partition_rows)
        SELECT @current_update_id, P.table_name,P.partition_name,P.partition_ordinal_position,P.partition_method,P.partition_expression,
            (CASE WHEN T.partition_description IS NULL THEN 0 ELSE T.partition_description END),
            (CASE WHEN P.partition_description='MAXVALUE' THEN 2000000000 ELSE P.partition_description END),
            P.table_rows
        FROM information_schema.partitions P
            LEFT OUTER JOIN (SELECT table_schema,table_name,partition_description,partition_ordinal_position
                            FROM information_schema.partitions WHERE table_schema=Database() AND partition_name IS NOT NULL) T
            ON P.table_schema=T.table_schema AND P.table_name=T.table_name AND P.partition_ordinal_position=T.partition_ordinal_position+1
        WHERE P.table_schema=Database() AND P.partition_name IS NOT NULL
        ORDER BY  P.table_name,P.partition_ordinal_position;

        CALL update_log_message('UPDATE TDR','Global db updates','TODO','Retrieve db state');
    END IF;

    SET OUT_status=1;
END $$
DELIMITER ;

-- CALL start_global_tdr_update( @status, @message);

-- Add if not exists ordinal_position into background_transfer_tables_description
CALL add_column_if_not_exists(Database(), 'background_transfer_tables_description', 'ordinal_position', ' INT NULL AFTER table_name', @status, @message);
DROP PROCEDURE IF EXISTS stop_global_tdr_update;
DELIMITER $$
CREATE PROCEDURE stop_global_tdr_update(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=0;

    CALL tdr_update_id(@current_update_id);

    UPDATE tdr_update_history
        SET end_time=now(), status='DONE'
        WHERE update_id=@current_update_id;

    CALL update_log_message('UPDATE TDR','Global db updates','DONE',null);
    SET OUT_status=1;
END $$
DELIMITER ;


-- ---------------------------------------------------------
-- CHECK VERSION PROCEDURE
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS is_compatible_version;
DELIMITER $$
CREATE PROCEDURE is_compatible_version(
    IN checked_version SMALLINT(5),
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE last_log_id INT;
    DECLARE old_update_id INT;
    DECLARE current_version_build SMALLINT(5) DEFAULT 0;
    DECLARE current_status TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SHOW ERRORS;
        SET OUT_message="Error SQL Exception";
        IF EXISTS(SELECT log_id FROM tdr_update_logs WHERE log_id>last_log_id AND status='FAIL')
        THEN
            SELECT CONCAT(date,' - ',action,' - ',description,' - ',status,' - ',message) FROM tdr_update_logs WHERE log_id>last_log_id  AND status='FAIL'
            INTO OUT_message;
        END IF;
    END;
    SET OUT_status=0;
    SET old_update_id=1;

    SELECT max(log_id) FROM tdr_update_logs INTO last_log_id;
    CALL update_log_message('UPDATE TDR','CHECK TDR VERSION','IN PROGRESS',null);
    SELECT db_version_build, db_status FROM global_info INTO current_version_build, current_status;

    -- if the update was stopped before the end
    -- we need to restart at the begining of this update
    IF (INSTR(current_status,'UPDATING_DATABASE')>0) THEN
        SET current_version_build = current_version_build-1;
    END IF;

    -- Check if the script update can be apply to the current version
    IF current_version_build <> checked_version THEN
        CALL update_log_message('UPDATE TDR','CHECK TDR VERSION','FAIL','Incompatible version');
        SELECT current_version_build FROM ERROR_INVALID_DATABASE_VERSION;
    END IF;

    -- if the update was stopped before the end
    -- The first step is to initialize or retrieve the @current_update_id
    IF EXISTS(SELECT update_id FROM tdr_update_history WHERE update_to IS NOT NULL AND status<>'DONE')
    THEN
        -- Have an update in progress
        -- Check if the version is compatible
        IF EXISTS(SELECT update_id FROM tdr_update_history WHERE status<>'DONE'
                AND (current_version_build+1)<>update_to)
        THEN
            CALL update_log_message('UPDATE TDR','CHECK UPDATE','FAIL','Have an incompatible update in progress?');
            SELECT current_version_build FROM ERROR_INCOMPATIBLE_DATABASE_UPDATE;
        END IF;
    END IF;

    -- Check if have a background transfer event is actived
    CALL background_transfer_event_is_activated(@background_event_enabled);
    IF (@background_event_enabled)
    THEN
        CALL update_log_message('UPDATE TDR','CHECK BACKGROUND PROCESS','FAIL','Background transfer event is running.\n Please stop it before to start the update.');
        SELECT current_version_build FROM ERROR_BACKGROUND_TRANSFER_RUNNING;
    END IF;

    SET OUT_status=1;
END $$
DELIMITER ;

-- ---------------------------------------------------------
-- CHECK BACKGROUND TRANSFER PROCESS COMPATIBLE WITH THE UPDATE OF THIS TABLE
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS check_table_for_update;
DELIMITER $$
CREATE PROCEDURE check_table_for_update(
    IN IN_table_name TEXT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE last_update_id INT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SHOW ERRORS;
    END;
    SET OUT_status=1;

    -- Check if have a background transfer actived
    -- A TDR can be uptodate but a background transfer can still be active
    CALL background_transfer_in_progress(@background_in_progress);
    IF (@background_in_progress)
    THEN
        -- A background transfer is running
        -- Check if we can update this table
        -- but ignore current update
        SELECT MAX(update_id) FROM tdr_update_history WHERE status='DONE' INTO last_update_id;
        IF EXISTS (SELECT status FROM background_transfer_tables WHERE update_id<=last_update_id AND status<>'DONE' AND table_name=IN_table_name)
        THEN
            SET OUT_message=CONCAT('A BackGround transfer stills running on table ',IN_table_name,'.\n You need first to finalize this transfer before to start this update...');
            SET OUT_status=0;
        END IF;
    END IF;

END $$
DELIMITER ;


-- ---------------------------------------------------------
-- UPDATE VERSION PROCEDURE
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS start_update;
DELIMITER $$
CREATE PROCEDURE start_update(
    IN IN_db_version_name TEXT,
    IN IN_db_version_nb INT,
    IN IN_db_version_build INT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE new_db_status TEXT;
    DECLARE current_version_build SMALLINT(5) DEFAULT 0;
    DECLARE current_db_status TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=0;

    CALL start_global_tdr_update( OUT_status, @OUT_message);

    IF (OUT_status=1) THEN

      CALL tdr_update_id(@current_update_id);

      SELECT db_version_build, db_status FROM global_info INTO current_version_build, current_db_status;

      UPDATE tdr_update_history
          SET update_to=IN_db_version_build,
          end_time=now(), status='IN PROGRESS'
      WHERE update_id=@current_update_id;

      SELECT db_status FROM global_info INTO current_db_status;
      IF (LENGTH(current_db_status) = 0) OR (current_db_status IS NULL) THEN
          SELECT 'UPDATING_DATABASE' INTO new_db_status;
      ELSEIF (INSTR(current_db_status, 'UPDATING_DATABASE') = 0) THEN
          SELECT CONCAT(current_db_status,'|','UPDATING_DATABASE') INTO new_db_status;
      ELSE
          SELECT current_db_status INTO new_db_status;
      END IF;

      UPDATE global_info SET
          db_version_name=IN_db_version_name,
          db_version_nb=IN_db_version_nb,
          db_version_build=IN_db_version_build,
          db_status = new_db_status;

      CALL update_log_message('UPDATE TDR',CONCAT('Start TDR update from ',current_version_build,' to ',IN_db_version_build),'TODO',null);

      -- For TokuDB, disable the Online Creation Index
      IF EXISTS (SELECT engine FROM information_schema.engines WHERE engine='TokuDB') THEN
          -- Then disable Online Creation Index
          SET @ddl=CONCAT('SET SESSION tokudb_create_index_online=OFF');
          PREPARE stmt FROM @ddl;
          EXECUTE stmt;
          DEALLOCATE PREPARE stmt;
      END IF;
    END IF;

    SET OUT_status=1;
END $$
DELIMITER ;

DROP PROCEDURE IF EXISTS add_status;
DELIMITER $$
CREATE PROCEDURE add_status(
    IN IN_status TEXT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE new_db_status TEXT;
    DECLARE current_db_status TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=0;

    SELECT db_status FROM global_info INTO current_db_status;
    IF (LENGTH(current_db_status) = 0) OR (current_db_status IS NULL) THEN
        SELECT IN_status INTO new_db_status;
    ELSEIF (INSTR(current_db_status, IN_status) = 0) THEN
        SELECT CONCAT(current_db_status,'|',IN_status) INTO new_db_status;
    END IF;

    IF (LENGTH(new_db_status) > 0) THEN
        UPDATE global_info SET db_status = new_db_status;
    END IF;


    SET OUT_status=1;
END $$
DELIMITER ;


-- ---------------------------------------------------------
-- DROP STATUS
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS remove_status;
DELIMITER $$
CREATE PROCEDURE remove_status(
    IN IN_status TEXT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE new_db_status TEXT;
    DECLARE current_db_status TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=0;

    SELECT db_status FROM global_info INTO current_db_status;
    IF (LENGTH(current_db_status) = 0) OR (current_db_status IS NULL) THEN
        SELECT '' INTO new_db_status;
    ELSEIF (current_db_status=IN_status) THEN
        SELECT '' INTO new_db_status;
    ELSEIF (INSTR(current_db_status,IN_status) > 0) THEN
        SELECT REPLACE(current_db_status,CONCAT('|',IN_status),'') INTO new_db_status;
        SELECT REPLACE(new_db_status,CONCAT(IN_status,'|'),'') INTO new_db_status;
    ELSE
        SELECT current_db_status INTO new_db_status;
    END IF;

    SELECT new_db_status;
    IF (LENGTH(new_db_status) > 0) THEN
        UPDATE global_info SET db_status = new_db_status;
    ELSE
        UPDATE global_info SET db_status = null;
    END IF;
    SET OUT_status=1;
END $$
DELIMITER ;


-- ---------------------------------------------------------
-- UPDATE VERSION PROCEDURE
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS stop_update;
DELIMITER $$
CREATE PROCEDURE stop_update(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE current_db_status TEXT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=0;

    CALL tdr_update_id(@current_update_id);
    CALL tdr_build_version(@current_build_version);

    UPDATE tdr_update_history
        SET end_time=now(),
        status='DONE'
    WHERE update_id=@current_update_id;

    CALL remove_status('UPDATING_DATABASE', @status, @message);
    CALL update_log_message('UPDATE TDR',CONCAT('Stop db update to ',@current_build_version),'DONE','End of update db version');

    SELECT db_status FROM global_info INTO current_db_status;
    CALL update_log_message('UPDATE TDR','Stop db update','DONE',CONCAT('New db Status ',current_db_status));

    CALL stop_global_tdr_update( OUT_status, OUT_message);

    SET OUT_status=1;
END $$
DELIMITER ;

-- ---------------------------------------------------------
-- BACKGROUND TRANSFER PROCEDURE/FUNCTION
-- ---------------------------------------------------------

-- Background transfer settings
DROP PROCEDURE IF EXISTS background_transfer_add_settings;
DELIMITER $$
CREATE PROCEDURE background_transfer_add_settings(
    IN IN_setting_key VARCHAR(255),
    IN IN_setting_value VARCHAR(255),
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
   DECLARE EXIT HANDLER FOR SQLEXCEPTION
       SET OUT_message="Error SQL Exception";
    SET OUT_status=0;

    -- use the new tdr_update_id
    CALL tdr_update_id(@current_update_id);
    IF (IN_setting_key<>'TABLE')
    THEN
        -- Only one value
        DELETE FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key=IN_setting_key;
    END IF;

    IF NOT EXISTS (SELECT setting_value FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key=IN_setting_key AND setting_value=IN_setting_value)
    THEN
        INSERT INTO background_transfer_settings(update_id,setting_key,setting_value)
        VALUES(@current_update_id,IN_setting_key,IN_setting_value);
    END IF;

    SET OUT_status=1;
END $$
DELIMITER ;

-- retun TRUE if have a background transfer event activated
DROP FUNCTION IF EXISTS background_transfer_event_is_activated;
DROP PROCEDURE IF EXISTS background_transfer_event_is_activated;
DELIMITER $$
CREATE PROCEDURE background_transfer_event_is_activated(OUT OUT_is_activated BOOLEAN)
BEGIN
    SELECT FALSE INTO OUT_is_activated;
    IF EXISTS (SELECT status FROM information_schema.events WHERE event_schema=Database() AND event_name='background_transfer' AND  status='ENABLED') THEN
      SELECT TRUE INTO OUT_is_activated;
    END IF;
END;
$$
DELIMITER ;

-- retun TRUE if have a background transfer activated for the current update
DROP FUNCTION IF EXISTS background_transfer_is_activated;
DROP PROCEDURE IF EXISTS background_transfer_is_activated;
DELIMITER $$
CREATE PROCEDURE background_transfer_is_activated(OUT OUT_is_activated BOOLEAN)
BEGIN
    CALL background_update_id(@current_update_id);

    SELECT COUNT(setting_value)>0 FROM background_transfer_settings
                WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER' AND setting_value='ENABLED'
                INTO OUT_is_activated;
END;
$$
DELIMITER ;

-- retun TRUE if have a background_transfer_in_progress for the current update
DROP FUNCTION IF EXISTS background_transfer_in_progress;
DROP PROCEDURE IF EXISTS background_transfer_in_progress;
DELIMITER $$
CREATE PROCEDURE background_transfer_in_progress(OUT OUT_in_progress BOOLEAN)
BEGIN
    SELECT COUNT(update_id)>0 FROM background_transfer_history
        WHERE status='IN PROGRESS'
        INTO OUT_in_progress;
END;
$$
DELIMITER ;

-- ---------------------------------------------------------
-- CHECK BACKGROUND TRANSFER
-- IF INCOMPATIBLE -> ERROR
-- IF NOTHING TO DO -> CLEAN
-- ---------------------------------------------------------

DROP PROCEDURE IF EXISTS background_transfer_check_settings;
DELIMITER $$
CREATE PROCEDURE background_transfer_check_settings(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE current_table_name VARCHAR(65);
    DECLARE background_is_activated BOOLEAN;
    DECLARE background_table_name VARCHAR(65);
    DECLARE not_found BOOLEAN DEFAULT false;
    DECLARE tables_for_background CURSOR FOR
        SELECT setting_value FROM background_transfer_settings WHERE update_id=@current_update_id AND setting_key='TABLE';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_found = TRUE;

    SET OUT_status=1;

    -- use the new tdr_update_id
    CALL tdr_update_id(@current_update_id);
    CALL tdr_build_version(@current_build_version);
    SELECT COUNT(setting_value)>0 FROM background_transfer_settings
                WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER' AND setting_value='ENABLED'
                INTO background_is_activated;

    -- For all tables, check if have data and update the table_rows
    OPEN tables_for_background;
        SET not_found = false;
        REPEAT
            FETCH tables_for_background INTO current_table_name;
            IF NOT not_found THEN
                -- Check if table _background exists
                SELECT CONCAT(current_table_name,'_background') INTO background_table_name;
                IF NOT EXISTS (SELECT table_name FROM information_schema.tables
                    WHERE table_schema=Database() AND table_name=background_table_name)
                THEN
                    -- Then check on the original table
                    SET @ddl=CONCAT('UPDATE tdr_update_tables_state SET table_rows=(CASE WHEN (SELECT MIN(splitlot_id) FROM ',
                    Database(),'.',current_table_name,') IS NULL THEN 0 ELSE table_rows END) WHERE update_id=',@current_update_id,
                    ' AND table_name = "',current_table_name,'"');
                    PREPARE stmt FROM @ddl;
                    EXECUTE stmt;
                    DEALLOCATE PREPARE stmt;
                END IF;
            END IF;
        UNTIL not_found = true
        END REPEAT;
    CLOSE tables_for_background;

    -- Remove from the settings empty tables
    DELETE FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key='TABLE' AND setting_value IN
        (SELECT table_name FROM tdr_update_tables_state S
            WHERE S.update_id=@current_update_id AND S.table_rows=0);

    -- SOME CHECK
    -- Check if have some an update in progress
    IF (background_is_activated
        AND (@current_build_version IS NULL))
    THEN
        -- ERROR
        SET OUT_status=0;
        SET OUT_message = 'Initialization error';
        UPDATE background_transfer_settings SET setting_value='DISABLED' WHERE  update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER';
    END IF;

    -- Check if have some tables for background
    IF (background_is_activated)
        AND (NOT EXISTS (SELECT * FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key='TABLE'))
    THEN
        -- NOTHING TO DO
        -- NO ERROR
        SET OUT_status=1;
        SET OUT_message = 'Nothing to do';
        UPDATE background_transfer_settings SET setting_value='DISABLED' WHERE  update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER';
    END IF;

    -- Check if have some data for tables in background
    IF (background_is_activated)
        AND (NOT EXISTS (SELECT * FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key='TABLE'))
    THEN
        -- NOTHING TO DO
        -- NO ERROR
        SET OUT_status=1;
        SET OUT_message = 'Nothing to do';
        UPDATE background_transfer_settings SET setting_value='DISABLED' WHERE  update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER';
    END IF;

    IF (background_is_activated)
        AND (NOT EXISTS (SELECT * FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER_INCREMENT'))
    THEN
        -- NEED THE INCREMENT
        SET OUT_status=0;
        SET OUT_message = 'No INCREMENT settings defined';
        UPDATE background_transfer_settings SET setting_value='DISABLED' WHERE  update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER';
    END IF;

    IF (background_is_activated) AND
    (EXISTS (
        SELECT setting_value FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key='TABLE'
        AND setting_value NOT IN (SELECT C.table_name FROM information_schema.columns C
                                    WHERE C.table_schema=Database() AND C.column_name='splitlot_id'
                                    AND C.table_name NOT LIKE '%t_splitlot')
        ))
    THEN
        -- Incorrect settings
        -- only table linked to splitlot_id field can be selected for the background transfer
        SET OUT_status=0;
        SET OUT_message = 'Invalid tables list - only table linked to splitlot_id field can be selected for the background transfer';
        UPDATE background_transfer_settings SET setting_value='DISABLED' WHERE  update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER';
    END IF;

    IF (OUT_status=0)
    THEN
        CALL update_log_message('UPDATE TDR','Background Transfer Settings','FAIL',null);
    ELSE
        CALL update_log_message('UPDATE TDR','Background Transfer Settings','DONE',null);
    END IF;

    IF (background_is_activated)
    THEN
        CALL background_transfer_log_message(@current_update_id,'TRANSFER DATA','Background Transfer is activated','DONE',null);
    END IF;
END $$
DELIMITER ;

-- ---------------------------------------------------------
-- INITIALIZATION OF THE BACKGROUND TRANSFER
-- THE background_transfer EVENT MUST BE DISABLED
-- ---------------------------------------------------------
DROP PROCEDURE IF EXISTS background_transfer_initialization;
DELIMITER $$
CREATE PROCEDURE background_transfer_initialization(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE ft_max_splitlot INT;
    DECLARE ft_min_splitlot INT;
    DECLARE wt_max_splitlot INT;
    DECLARE wt_min_splitlot INT;
    DECLARE et_max_splitlot INT;
    DECLARE et_min_splitlot INT;
    DECLARE max_splitlot INT;
    DECLARE min_splitlot INT;
    DECLARE current_table_name VARCHAR(65);
    DECLARE background_is_activated BOOLEAN;
    DECLARE background_table_name VARCHAR(65);
    DECLARE current_background_activation VARCHAR(45);
    DECLARE current_index_increment INT;

    DECLARE not_found BOOLEAN DEFAULT false;
    DECLARE tables_for_background CURSOR FOR
        SELECT setting_value FROM background_transfer_settings WHERE update_id=@current_update_id AND setting_key='TABLE';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_found = TRUE;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;

    SET OUT_status=1;
    SET OUT_message='No background process';

    CALL tdr_update_id(@current_update_id);
    CALL tdr_build_version(@current_build_version);
    SELECT COUNT(setting_value)>0 FROM background_transfer_settings
                WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER' AND setting_value='ENABLED'
                INTO background_is_activated;

    -- For this current update
    -- Check if a background transfer was required
    IF (background_is_activated)
    THEN

        SET OUT_status=0;
        SET OUT_message='No initialization error';

        SELECT setting_value FROM background_transfer_settings
        WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER_INCREMENT' INTO current_index_increment;

        -- This procedure prepare the TDR for an Incremental update of the schema
        -- Because the upgrade will modified some table definitions,
        -- for all HUGE tables, it is recommended to work on an empty table
        -- and repopulate the table with background process


        -- This procedure creates some tables to manage the BackGround process
        -- table TDR_UPDATE_HISTORY contains the current update
        SELECT MAX(splitlot_id) AS splitlot_max, MIN(splitlot_id) AS splitlot_min FROM ft_splitlot
            INTO ft_max_splitlot,ft_min_splitlot;
        SELECT MAX(splitlot_id) AS splitlot_max, MIN(splitlot_id) AS splitlot_min FROM wt_splitlot
            INTO wt_max_splitlot,wt_min_splitlot;
        SELECT MAX(splitlot_id) AS splitlot_max, MIN(splitlot_id) AS splitlot_min FROM et_splitlot
            INTO et_max_splitlot,et_min_splitlot;

        SELECT MAX(splitlot_max), MIN(splitlot_min) FROM
        (   SELECT ft_max_splitlot AS splitlot_max, ft_min_splitlot AS splitlot_min
        UNION
            SELECT wt_max_splitlot AS splitlot_max, wt_min_splitlot AS splitlot_min
        UNION
            SELECT et_max_splitlot AS splitlot_max, et_min_splitlot AS splitlot_min
        ) T INTO max_splitlot,min_splitlot;

        -- INSERT IGNORE TO NOT HAVE DUPLICATE LINE
        INSERT IGNORE INTO background_transfer_history(update_id,min_index,max_index,current_index,current_sid,start_time,end_time,status)
        VALUES (@current_update_id ,min_splitlot,max_splitlot,max_splitlot,null,now(),now(),'IN PROGRESS');

        -- table TDR_UPDATE_TABLES contains the list of tables to manage
        -- You can add here some other tables to manage with the BackGround process
        -- INSERT IGNORE TO NOT HAVE DUPLICATE LINE
        INSERT IGNORE INTO background_transfer_tables
        (update_id,table_name,min_index,max_index,current_index,current_sid,start_time,end_time,status)
            SELECT update_id, setting_value,
            (CASE WHEN INSTR(setting_value,'ft') THEN ft_min_splitlot ELSE (CASE WHEN INSTR(setting_value,'wt') THEN wt_min_splitlot ELSE et_min_splitlot END)END),
            (CASE WHEN INSTR(setting_value,'ft') THEN ft_max_splitlot ELSE (CASE WHEN INSTR(setting_value,'wt') THEN wt_max_splitlot ELSE et_max_splitlot END)END),
            (CASE WHEN INSTR(setting_value,'ft') THEN ft_max_splitlot ELSE (CASE WHEN INSTR(setting_value,'wt') THEN wt_max_splitlot ELSE et_max_splitlot END)END),
            null,null,null,'TODO'
            FROM background_transfer_settings WHERE update_id=@current_update_id AND setting_key='TABLE';

        -- INSERT IGNORE TO NOT HAVE DUPLICATE LINE
        INSERT IGNORE INTO background_transfer_tables_description (update_id,build_version,table_name,ordinal_position,column_name,expression)
            (SELECT @current_update_id, @current_build_version, T.table_name,C.ordinal_position,C.column_name,null
            FROM background_transfer_tables T INNER JOIN information_schema.columns C
            ON C.table_schema=Database() AND T.table_name=C.table_name
            WHERE T.update_id=@current_update_id
            ORDER BY C.table_name,C.ordinal_position);

        -- table TDR_UPDATE_PARTITIONS contains the list of partitions to manage
        -- INSERT IGNORE TO NOT HAVE DUPLICATE LINE
        -- Initialize the current_index to 0 if partition_rows=0
        INSERT IGNORE INTO background_transfer_partitions (update_id,table_name,partition_name,min_index,max_index,current_index,current_sid,start_time,end_time,status)
            (SELECT @current_update_id,P.table_name,P.partition_name,T.min_index,T.max_index,IF(T.partition_rows=0,0,T.max_index),null,null,null,'TODO'
            FROM information_schema.partitions P
            INNER JOIN background_transfer_settings S
            ON P.table_schema=Database() AND S.setting_key='TABLE' AND P.table_name=S.setting_value
            INNER JOIN tdr_update_partitions_state T
            ON T.update_id=S.update_id AND T.table_name=P.table_name AND T.partition_name=P.partition_name
            WHERE T.update_id=@current_update_id
            ORDER BY  P.table_name,P.partition_ordinal_position);

        -- Adjust the real index used
        -- for partitions with rows
        UPDATE background_transfer_partitions P
            INNER JOIN tdr_update_partitions_state T
            ON T.update_id=P.update_id AND T.table_name=P.table_name AND T.partition_name=P.partition_name
            SET P.max_index=
            (CASE WHEN T.table_name LIKE 'ft%' THEN (SELECT (CASE WHEN MAX(splitlot_id) IS NULL THEN T.min_index ELSE MAX(splitlot_id) END) FROM ft_splitlot WHERE splitlot_id>=T.min_index AND splitlot_id<T.max_index)
            ELSE (CASE WHEN T.table_name LIKE 'wt%' THEN (SELECT (CASE WHEN MAX(splitlot_id) IS NULL THEN T.min_index ELSE MAX(splitlot_id) END) FROM wt_splitlot WHERE splitlot_id>=T.min_index AND splitlot_id<T.max_index)
            ELSE (SELECT (CASE WHEN MAX(splitlot_id) IS NULL THEN T.min_index ELSE MAX(splitlot_id) END) FROM et_splitlot WHERE splitlot_id>=T.min_index AND splitlot_id<T.max_index) END) END)
            WHERE P.update_id=@current_update_id AND T.max_index<2000000000
            AND T.partition_rows>0;

        -- Initialize the current index
        -- current_index was intialized with the MAX partition description
        -- now we want to use the exacte MAX(splitlot_id)
        UPDATE background_transfer_partitions P
            SET P.current_index=P.max_index
            WHERE P.update_id=@current_update_id
            AND P.current_index>0;


        UPDATE background_transfer_partitions P
            INNER JOIN tdr_update_partitions_state T
            ON T.update_id=P.update_id AND T.table_name=P.table_name AND T.partition_name=P.partition_name
            SET P.min_index=
            (CASE WHEN T.table_name LIKE 'ft%' THEN (SELECT (CASE WHEN MIN(splitlot_id) IS NULL THEN T.min_index ELSE MIN(splitlot_id) END) FROM ft_splitlot WHERE splitlot_id>=T.min_index AND splitlot_id<T.max_index)
            ELSE (CASE WHEN T.table_name LIKE 'wt%' THEN (SELECT (CASE WHEN MIN(splitlot_id) IS NULL THEN T.min_index ELSE MIN(splitlot_id) END) FROM wt_splitlot WHERE splitlot_id>=T.min_index AND splitlot_id<T.max_index)
            ELSE (SELECT (CASE WHEN MIN(splitlot_id) IS NULL THEN T.min_index ELSE MIN(splitlot_id) END) FROM et_splitlot WHERE splitlot_id>=T.min_index AND splitlot_id<T.max_index) END) END)
            WHERE P.update_id=@current_update_id AND T.max_index<2000000000;

        -- Replace index highest than table max_index
        UPDATE background_transfer_partitions P
            INNER JOIN background_transfer_tables T
            ON T.update_id=P.update_id AND T.table_name=P.table_name
            SET P.max_index=T.max_index,
            P.current_index=T.max_index
            WHERE P.update_id=@current_update_id AND P.max_index>T.max_index
            AND P.current_index>0;

        -- Update current_index=0 that not need to be transfered because no data
        UPDATE background_transfer_partitions
            SET current_index=0
            WHERE update_id=@current_update_id AND min_index>max_index
            AND current_index>0;

        -- Add a dummy NO_PARTITION for tables without partitions as all the transfer algorithm is based on this
        INSERT INTO background_transfer_partitions (update_id,table_name,partition_name,min_index,max_index,current_index,current_sid,status)
            (SELECT T.update_id, T.table_name, 'NO_PARTITION' AS partition_name, T.min_index, T.max_index, T.max_index, null, 'TODO'
            FROM background_transfer_tables T
            WHERE T.update_id=@current_update_id
            AND T.table_name NOT IN
                (SELECT DISTINCT P.table_name FROM background_transfer_partitions P WHERE P.update_id=@current_update_id));

        OPEN tables_for_background;
            SET not_found = false;
            REPEAT
                FETCH tables_for_background INTO current_table_name;
                IF NOT not_found THEN
                    -- Check if table _background exists
                    SELECT CONCAT(current_table_name,'_background') INTO background_table_name;
                    IF NOT EXISTS (SELECT table_name FROM information_schema.tables
                        WHERE table_schema=Database() AND table_name=background_table_name)
                    THEN
                        -- Then rename table to _background
                        SET @ddl=CONCAT('ALTER TABLE ',Database(),'.',current_table_name,
                            ' RENAME TO ',current_table_name,'_background');
                        PREPARE stmt FROM @ddl;
                        EXECUTE stmt;
                        DEALLOCATE PREPARE stmt;
                    END IF;
                    -- Check if the table copy exists
                    IF NOT EXISTS (SELECT table_name FROM information_schema.tables
                        WHERE table_schema=Database() AND table_name=current_table_name)
                    THEN
                        -- and create duplicated table structure with index and partition
                        SET @ddl=CONCAT('CREATE TABLE ',Database(),'.',current_table_name,
                            ' LIKE ',current_table_name,'_background');
                        PREPARE stmt FROM @ddl;
                        EXECUTE stmt;
                        DEALLOCATE PREPARE stmt;
                    END IF;
                END IF;
            UNTIL not_found = true
            END REPEAT;
        CLOSE tables_for_background;

        CALL background_transfer_log_message(@current_update_id,'TRANSFER DATA','Background Transfer initialization','DONE',null);


        SET OUT_status=1;
        SET OUT_message='';
    END IF;
END $$
DELIMITER ;

DROP PROCEDURE IF EXISTS background_transfer_add_custom_transfer_description;
DELIMITER $$
CREATE PROCEDURE background_transfer_add_custom_transfer_description(
    IN  IN_table_name VARCHAR(65),
    IN  IN_column_name VARCHAR(65),
    IN  IN_expression TEXT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE background_is_activated BOOLEAN;
    DECLARE ordinal_position_count INT DEFAULT 0;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=1;

    CALL tdr_update_id(@current_update_id);
    CALL tdr_build_version(@current_build_version);
    SELECT COUNT(setting_value)>0 FROM background_transfer_settings
                WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER' AND setting_value='ENABLED'
                INTO background_is_activated;

    IF (background_is_activated)
    THEN
        -- Check if the table is referenced
        IF NOT EXISTS (SELECT expression FROM background_transfer_tables_description
            WHERE update_id=@current_update_id AND table_name=IN_table_name)
        THEN
            SELECT * FROM ERROR_NO_BACKGROUND_INITIALIZATION;
        END IF;

        -- Check if the column exists (can be a special INIT or ORDER BY)
        IF NOT EXISTS (SELECT expression FROM background_transfer_tables_description
            WHERE update_id=@current_update_id AND table_name=IN_table_name AND column_name=IN_column_name)
        THEN
            IF (IN_column_name<>'INIT' AND IN_column_name<> 'ORDER BY') THEN
                SELECT MAX(ordinal_position)+1 FROM background_transfer_tables_description WHERE update_id=@current_update_id AND table_name=IN_table_name INTO ordinal_position_count;
            END IF;
            INSERT INTO background_transfer_tables_description(update_id,build_version,table_name,ordinal_position,column_name,expression)
            VALUES(@current_update_id,@current_build_version,IN_table_name,ordinal_position_count,IN_column_name,NULL);
        END IF;

        -- Check if have already a custom update
        IF EXISTS (SELECT expression FROM background_transfer_tables_description
            WHERE update_id=@current_update_id AND table_name=IN_table_name AND column_name=IN_column_name AND expression IS NOT NULL)
        THEN
            SELECT * FROM ERROR_CANNOT_MANAGE_MULTI_BACKGROUND_TRANSFER;
        END IF;


        -- Update the line
        UPDATE background_transfer_tables_description
            SET build_version=@current_build_version, expression=IN_expression
            WHERE update_id=@current_update_id AND table_name=IN_table_name AND column_name=IN_column_name;

        SET OUT_status=1;
    END IF;

END $$
DELIMITER ;

DROP PROCEDURE IF EXISTS background_transfer_copy_data;
DELIMITER $$
CREATE PROCEDURE background_transfer_copy_data(
    IN  IN_update_id INT,
    IN  IN_table_name VARCHAR(65),
    IN  IN_background_table_name VARCHAR(65),
    IN  IN_starting_splitlot INT,
    IN  IN_ending_splitlot INT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message TEXT
)
BEGIN
    DECLARE exec_cmd TEXT;
    DECLARE order_by TEXT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;

        SET OUT_message=CONCAT("Error SQL Exception: ",@msg, '. On Query: ', @ddl);

        IF (IN_table_name IS NOT NULL)
        THEN
            CALL background_transfer_log_message(IN_update_id,'TRANSFER DATA',IN_table_name,'FAIL',OUT_message);
        ELSE
            CALL background_transfer_log_message(IN_update_id,'TRANSFER DATA','Background Transfer','FAIL',OUT_message);
        END IF;
    END;

    SET OUT_status = 0;

    CALL background_transfer_log_message(IN_update_id,'TRANSFER DATA',IN_table_name,'IN PROGRESS',CONCAT('WHERE splitlot_id>=',IN_starting_splitlot,' AND splitlot_id<=',IN_ending_splitlot));

    SET autocommit=0;
    SET foreign_key_checks=0;
    SET unique_checks=0;

    -- Clean data before insertion
    SELECT CONCAT('SELECT count(*) INTO @nb_splitlots FROM (SELECT DISTINCT splitlot_id FROM ',IN_table_name,' ',
        'WHERE splitlot_id>=',IN_starting_splitlot,' AND splitlot_id<=',IN_ending_splitlot,')T')
        INTO exec_cmd;
    SET @ddl=exec_cmd;
    PREPARE stmt FROM @ddl;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    IF (@nb_splitlots > 0)
    THEN
        SELECT CONCAT('DELETE FROM ',IN_table_name,' ',
            'WHERE splitlot_id>=',IN_starting_splitlot,' AND splitlot_id<=',IN_ending_splitlot)
            INTO exec_cmd;
        SET @ddl=exec_cmd;
        PREPARE stmt FROM @ddl;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END IF;

    -- Execute the Init query if any
    IF EXISTS (
        SELECT expression FROM background_transfer_tables_description
            WHERE update_id=IN_update_id AND table_name=IN_table_name AND column_name='INIT'
    ) THEN
        SELECT expression FROM background_transfer_tables_description
            WHERE update_id=IN_update_id AND table_name=IN_table_name AND column_name='INIT'
            INTO exec_cmd;

          -- split INIT command and EXECUTE
        SET @split_done = 0;
        SET @split_pos = 1;

        WHILE NOT @split_done DO
            SET @split_cmd = substring(exec_cmd, @split_pos,
                IF(locate(';', exec_cmd, @split_pos) > 0,
                locate(';', exec_cmd, @split_pos) - @split_pos,
                LENGTH(exec_cmd)));

            IF LENGTH(TRIM(@split_cmd)) > 0
            THEN
                SET @split_pos = @split_pos + LENGTH(@split_cmd) + 1;
                SET @ddl=@split_cmd;
                PREPARE stmt FROM @ddl;
                EXECUTE stmt;
                DEALLOCATE PREPARE stmt;
            ELSE
                SET @split_done = 1;
            END IF;
        END WHILE;
    END IF;

    -- Get the order by if any
    SELECT expression FROM background_transfer_tables_description
        WHERE update_id=IN_update_id AND table_name=IN_table_name AND column_name='ORDER BY'
        INTO order_by;

      -- Transfer the data
      SELECT CONCAT('INSERT INTO ',IN_table_name,' (',GROUP_CONCAT(column_name ORDER BY ordinal_position),') ',
          '(SELECT ',GROUP_CONCAT((CASE WHEN expression IS NULL THEN column_name ELSE CONCAT(expression,' as ',column_name) END) ORDER BY ordinal_position),' FROM ',IN_background_table_name,' ',
        'WHERE splitlot_id>=',IN_starting_splitlot,' AND splitlot_id<=',IN_ending_splitlot,(CASE WHEN order_by IS NULL THEN ' ' ELSE CONCAT(' ORDER BY ',order_by) END),')')
      FROM background_transfer_tables_description
      WHERE update_id=IN_update_id AND table_name=IN_table_name AND column_name<>'INIT'  AND column_name<>'ORDER BY'  AND IFNULL(expression,'')<>'IGNORE'
          INTO exec_cmd;
      SET @ddl=exec_cmd;
      PREPARE stmt FROM @ddl;
      EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    SET unique_checks=1;
    SET foreign_key_checks=1;
    SET autocommit=1;
    COMMIT;

    CALL background_transfer_log_message(IN_update_id,'TRANSFER DATA',IN_table_name,'DONE',CONCAT('WHERE splitlot_id>=',IN_starting_splitlot,' AND splitlot_id<=',IN_ending_splitlot));

    SET OUT_status = 1;
END $$
DELIMITER ;

DROP PROCEDURE IF EXISTS background_transfer_check_partition;
DELIMITER $$
CREATE PROCEDURE background_transfer_check_partition(
  IN  IN_update_id INT,
    IN  IN_table_name VARCHAR(65),
    IN  IN_background_table_name VARCHAR(65),
    IN  IN_min_splitlot INT,
    IN  IN_max_splitlot INT,
    OUT OUT_status TINYINT(1),
    OUT OUT_message TEXT
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;

        SET OUT_message=CONCAT("Error SQL Exception: ",@msg, '. On Query: ', @Query);

        IF (IN_table_name IS NOT NULL)
        THEN
            CALL background_transfer_log_message(IN_update_id,'CHECK DATA',IN_table_name,'FAIL',OUT_message);
        ELSE
            CALL background_transfer_log_message(IN_update_id,'CHECK DATA','Background Transfer','FAIL',OUT_message);
        END IF;
    END;

    SET OUT_status = 0;
    SET @Progress = 'FAIL';

    CALL background_transfer_log_message(IN_update_id,'CHECK DATA',IN_table_name,'IN PROGRESS',CONCAT('WHERE splitlot_id>=',IN_min_splitlot,' AND splitlot_id<=',IN_max_splitlot));

    -- Check the number of distinct splitlots on this section
    SET @Query = CONCAT('SELECT COUNT(*) INTO @var1 FROM (SELECT DISTINCT splitlot_id FROM ', IN_table_name, ' WHERE splitlot_id >= ', IN_min_splitlot, ' AND splitlot_id <= ', IN_max_splitlot,')T');
    PREPARE stmt FROM @Query;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    SET @Query = CONCAT('SELECT COUNT(*) INTO @var2 FROM (SELECT DISTINCT splitlot_id FROM ', IN_background_table_name, ' WHERE splitlot_id >= ', IN_min_splitlot, ' AND splitlot_id <= ', IN_max_splitlot,')T');
    PREPARE stmt FROM @Query;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    SET OUT_status = (@var1 = @var2);
    IF (@var1 = @var2)
    THEN
        SET @Progress = 'DONE';
    ELSE
        SET @Progress = 'FAIL';
        SET OUT_message = 'Number of distinct splitlots doesnt match';
    END IF;

    CALL background_transfer_log_message(IN_update_id,'CHECK DATA',IN_table_name,@Progress,CONCAT('WHERE splitlot_id>=',IN_min_splitlot,' AND splitlot_id<=',IN_max_splitlot));
END $$
DELIMITER ;

DROP PROCEDURE IF EXISTS background_transfer_update_table_history;
DELIMITER $$
CREATE PROCEDURE background_transfer_update_table_history(
    IN IN_update_id INT,
    IN IN_table_name VARCHAR(65)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SHOW ERRORS;

        GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;

    CALL background_transfer_log_message(IN_update_id,'CLEANUP',IN_table_name,'FAIL',CONCAT('SQL exception: ', @msg));
    END;

    CALL background_transfer_log_message(IN_update_id,'CLEANUP',IN_table_name,'IN PROGRESS','Updating the tables and history status');

    -- get the min current_sid and max current_index
    SELECT
        MAX(current_index)
    FROM
        background_transfer_partitions
    WHERE
        update_id = IN_update_id
        AND table_name = IN_table_name
    INTO
        @maxIndex;

    -- update the tables table
    UPDATE
        background_transfer_tables
    SET
        current_index = @maxIndex
    WHERE
        update_id=IN_update_id
        AND table_name = IN_table_name;

    -- get the min current_sid and max current_index
    SELECT
        MIN(current_sid),
        MAX(current_index)
    FROM
        background_transfer_tables
    WHERE
        update_id = IN_update_id
    INTO
        @minSid,
        @maxIndex;

    -- Update the history table
    UPDATE
        background_transfer_history
    SET
        current_sid = @minSid,
        current_index = @maxIndex
    WHERE
        update_id = IN_update_id;

    CALL background_transfer_log_message(IN_update_id,'CLEANUP',IN_table_name,'DONE','Tables and history status updated');

  
END $$
DELIMITER ;

-- Execute the background TDR update step by step
DROP PROCEDURE IF EXISTS background_transfer_increment;
DELIMITER $$
CREATE PROCEDURE background_transfer_increment(
    IN  IN_update_id INT,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message TEXT)
proc_label:BEGIN
    DECLARE max_threads INT;
    DECLARE current_threads_count INT;
    DECLARE parallel_granularity VARCHAR(25);
    DECLARE splitlot_increment INT;
    DECLARE current_connection_id INT DEFAULT NULL;
    DECLARE current_table_name VARCHAR(65) DEFAULT NULL;
    DECLARE background_table_name VARCHAR(65);
    DECLARE current_partition_name VARCHAR(65) DEFAULT NULL;
    DECLARE starting_splitlot INT DEFAULT NULL;
    DECLARE ending_splitlot INT DEFAULT NULL;
    DECLARE current_splitlot INT DEFAULT NULL;
    DECLARE min_splitlot INT DEFAULT NULL;
    DECLARE max_splitlot INT DEFAULT NULL;
    DECLARE date_now DATETIME;
    DECLARE exec_cmd TEXT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SHOW ERRORS;

        GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;

        SET OUT_status=0;

        IF (current_table_name IS NOT NULL) THEN
          CALL background_transfer_log_message(IN_update_id,'INCREMENT',current_table_name,'FAIL',CONCAT('SQL exception: ', @msg));
        ELSE
          CALL background_transfer_log_message(IN_update_id,'INCREMENT','Background transfer','FAIL',CONCAT('SQL exception: ', @msg));
        END IF;

        UPDATE
          background_transfer_partitions
        SET
          current_sid = NULL,
          status = 'FAIL'
        WHERE
          current_sid = connection_id();

        UPDATE
          background_transfer_tables
        SET
          current_sid = NULL
        WHERE
          current_sid = connection_id();
    END;

    CALL background_transfer_log_message(IN_update_id,'INCREMENT','Background transfer','STARTING','Starting new increment');

    SET date_now = now();
    SET current_connection_id = connection_id();
    SET OUT_status=0;

    -- PART 0: Get the parallelisation parameters

    -- Get the maximum number of allowed threads
    SELECT
        IFNULL(setting_value, 1)
    FROM
        background_transfer_settings
    WHERE
        update_id=IN_update_id
        AND setting_key='BACKGROUND_TRANSFER_MAX_THREADS'
    LIMIT 1
    INTO
        max_threads;

    -- Get the splitlot increment
    SELECT
        IFNULL(setting_value, 10)
    FROM
        background_transfer_settings
    WHERE
        update_id=IN_update_id
        AND setting_key='BACKGROUND_TRANSFER_INCREMENT'
    LIMIT 1
    INTO
        splitlot_increment;

    -- PART I: select the next table and partition to proceed

    CALL background_transfer_log_message(IN_update_id,'INCREMENT','Background transfer','IN PROGRESS','Trying to lock a table');

    -- Try to take a token on the next available table
    UPDATE
        background_transfer_tables
    SET
        current_sid = current_connection_id
    WHERE
        update_id = IN_update_id
        AND status IN ('TODO', 'IN PROGRESS')
        AND current_sid IS NULL -- no other partition of this table is taken
    ORDER BY
        current_index DESC
    LIMIT 1;

    -- Check that we don't exceeded the max number of allowed threads
    SELECT
        COUNT(DISTINCT current_sid)
    FROM
        background_transfer_tables
    WHERE
        current_sid <> 0
    INTO
        current_threads_count;

    -- Free the token if exceeded
    IF (current_threads_count > max_threads) THEN
        CALL background_transfer_log_message(IN_update_id,'INCREMENT','Background transfer','ABORTING',CONCAT('Too much threads detected: ', current_threads_count, ', aborting'));

        UPDATE
            background_transfer_tables
        SET
            current_sid = NULL
        WHERE
            current_sid = current_connection_id;

        SET OUT_message='Too much threads at once, aborting';
        SET OUT_status=0;
        LEAVE proc_label;
    END IF;

    -- Now check that we actually took something
    IF (NOT EXISTS (
        SELECT
            current_sid
        FROM
            background_transfer_tables
        WHERE
            current_sid = current_connection_id)
    ) THEN
        CALL background_transfer_log_message(IN_update_id,'INCREMENT','Background transfer','ABORTING','Nothing left to transfer, aborting');

        SET OUT_message='Nothing left to transfer';
        SET OUT_status=0;
        LEAVE proc_label;
    END IF;

    -- Get the current job target
    SELECT
        btt.table_name,
        CONCAT(btt.table_name, '_background'),
        btp.partition_name,
        btp.current_index,
        btp.min_index,
        btp.max_index
    FROM
        background_transfer_tables btt
    JOIN
        background_transfer_partitions btp
        ON btt.update_id = btp.update_id
        AND btt.table_name = btp.table_name
    WHERE
        btt.current_sid = current_connection_id
        AND btp.status IN ('TODO', 'IN PROGRESS')
    ORDER BY
        btp.current_index DESC
    LIMIT 1
    INTO
        current_table_name,
        background_table_name,
        current_partition_name,
        ending_splitlot,
        min_splitlot,
        max_splitlot;

    -- Once again, check that we actually selected a partition
    IF(current_partition_name IS NULL) THEN
        -- There is no partition left to process
        CALL background_transfer_log_message(IN_update_id,'INCREMENT','Background transfer','ABORTING','No valid partitions left to transfer, aborting');

        SET OUT_message='No valid partition left to transfer';
        SET OUT_status=0;
        LEAVE proc_label;
    END IF;

    -- Update the partition status
    UPDATE
        background_transfer_partitions
    SET
        current_sid = current_connection_id,
        start_time = IFNULL(start_time, date_now),
        status = 'IN PROGRESS'
    WHERE
        update_id = IN_update_id
        AND table_name = current_table_name
        AND partition_name = current_partition_name;

    -- Update the table status
    UPDATE
        background_transfer_tables
    SET
        start_time = IFNULL(start_time, date_now),
        end_time = date_now,
        status = 'IN PROGRESS'
    WHERE
        update_id = IN_update_id
        AND table_name = current_table_name;

    -- Update the background transfer progress
    UPDATE background_transfer_history
    SET
        current_sid = current_connection_id,
        start_time = IFNULL(start_time, date_now),
        status='IN PROGRESS'
    WHERE
        update_id=IN_update_id;

    -- Set the splitlot range to transfer
    SET starting_splitlot = IF(ending_splitlot - splitlot_increment > min_splitlot, ending_splitlot - splitlot_increment, min_splitlot);

    -- PART II: perform the actual transfer

    IF (ending_splitlot <> 0) THEN
        CALL background_transfer_copy_data(
            IN_update_id,
            current_table_name,
            background_table_name,
            starting_splitlot,
            ending_splitlot,
            OUT_status,
            OUT_message
        );

        -- handle potential transfer error
        IF (OUT_status = 0) THEN
            CALL background_transfer_log_message(IN_update_id,'INCREMENT',current_table_name,'FAIL',CONCAT('Failed to transfer the data: ', OUT_message));

            UPDATE
                background_transfer_partitions
            SET
                current_sid = NULL,
                status = 'FAIL'
            WHERE
                current_sid = current_connection_id;

            UPDATE
                background_transfer_tables
            SET
                current_sid = NULL
            WHERE
                current_sid = current_connection_id;

            LEAVE proc_label;
        END IF;

        -- Compute the new "current_splitlot" from which the next partition increment will start
        SET current_splitlot = (CASE WHEN starting_splitlot - 1 < min_splitlot THEN 0 ELSE starting_splitlot - 1 END);
    ELSE
        -- The partition is already processed entirely
        SET current_splitlot = 0;
    END IF;

    -- PART III: Log the progress

    -- update the partition table
    UPDATE
        background_transfer_partitions
    SET
        current_index = current_splitlot
    WHERE
        update_id=IN_update_id
        AND table_name=current_table_name
        AND partition_name=current_partition_name;

    -- and check whether the partition transfer is over
    IF (current_splitlot = 0) THEN
        -- check that everything has been migrated
        CALL background_transfer_check_partition(
          IN_update_id,
          current_table_name,
          background_table_name,
          min_splitlot,
          max_splitlot,
          OUT_status,
          OUT_message);

        IF (OUT_status = 0) THEN
            CALL background_transfer_log_message(IN_update_id,'INCREMENT',current_table_name,'FAIL',CONCAT('A partition has not been entirely transferred: ', OUT_message));

            UPDATE
                background_transfer_partitions
            SET
                current_sid = NULL,
                status = 'FAIL'
            WHERE
                current_sid = current_connection_id;

            UPDATE
                background_transfer_tables
            SET
                current_sid = NULL
            WHERE
                current_sid = current_connection_id;

            LEAVE proc_label;
        END IF;

        IF NOT EXISTS (
            SELECT
                table_name
            FROM
                background_transfer_partitions
            WHERE
                update_id = IN_update_id
                AND table_name = current_table_name
                AND current_index <> 0
        ) THEN
            -- drop the table
            CALL background_transfer_log_message(IN_update_id,'DROP TABLE',background_table_name,'IN PROGRESS',background_table_name);

            SELECT CONCAT('DROP TABLE IF EXISTS ',background_table_name)
                INTO exec_cmd;
            SET @ddl=exec_cmd;
            PREPARE stmt FROM @ddl;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;

            CALL background_transfer_log_message(IN_update_id,'DROP TABLE',background_table_name,'DONE',background_table_name);

            -- log the fact that the table is done
            UPDATE
                background_transfer_tables
            SET
                current_index = 0,
                end_time = now(),
                status='DONE'
            WHERE
                update_id=IN_update_id
                AND table_name=current_table_name;

            -- log the fact that all the partitions are done
            UPDATE
                background_transfer_partitions
            SET
                current_index = 0,
                end_time = now(),
                status='DONE'
            WHERE
                update_id=IN_update_id
                AND table_name=current_table_name;

            CALL background_transfer_log_message(IN_update_id,'TRANSFER DATA',current_table_name,'DONE','Transfer completed');

            -- check whether the background update is over as well
            IF NOT EXISTS (
                SELECT
                    update_id
                FROM
                    background_transfer_tables
                WHERE
                    update_id = IN_update_id
                  AND status <> 'DONE'
            ) THEN
                -- log the fact that the update is done
                UPDATE
                    background_transfer_history
                SET
                    current_index = 0,
                    end_time=now(),
                    status='DONE'
                WHERE
                    update_id=IN_update_id;

                CALL background_transfer_log_message(IN_update_id,'TRANSFER DATA','Background Transfer finalization','DONE',null);

                SET OUT_message='Background Transfer completed';

                SET OUT_status=2;
            END IF;
        ELSE
            -- drop only the partition
            CALL background_transfer_log_message(IN_update_id,'DROP PARTITION',background_table_name,'IN PROGRESS',current_partition_name);

            SELECT CONCAT('ALTER TABLE ',background_table_name,' DROP PARTITION ',current_partition_name)
                INTO exec_cmd;
            SET @ddl=exec_cmd;
            PREPARE stmt FROM @ddl;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;

            CALL background_transfer_log_message(IN_update_id,'DROP PARTITION',background_table_name,'DONE',current_partition_name);

            -- Update the _tables and _history status
            CALL background_transfer_update_table_history(IN_update_id, current_table_name);
        END IF;

        -- log the fact that the partition is done
        UPDATE
            background_transfer_partitions
        SET
            end_time = now(),
            status='DONE'
        WHERE
            update_id=IN_update_id
            AND table_name=current_table_name
            AND partition_name=current_partition_name;
    ELSE
        -- Update the _tables and _history status
        CALL background_transfer_update_table_history(IN_update_id, current_table_name);
    END IF;

    -- Release the token on the table and the partition
    UPDATE
        background_transfer_partitions
    SET
        current_sid = NULL
    WHERE
        update_id=IN_update_id
        AND table_name=current_table_name
        AND partition_name=current_partition_name;

    UPDATE
        background_transfer_tables
    SET
        current_sid = NULL
    WHERE
        update_id=IN_update_id
        AND table_name=current_table_name;

    CALL background_transfer_log_message(IN_update_id,'INCREMENT',current_table_name,'ENDING','Ending increment');

    SET OUT_status=1;
END $$
DELIMITER ;

-- Execute during N seconds the background transfer increment
DROP PROCEDURE IF EXISTS background_transfer_step;
DELIMITER $$
CREATE PROCEDURE background_transfer_step(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message TEXT)
BEGIN
    DECLARE min_duration INT;
    DECLARE target_date DATETIME;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    END;
    SET OUT_status=0;

    -- Clean dead SIDs
    SELECT
        GROUP_CONCAT(ID)
    FROM information_schema.PROCESSLIST
    INTO
        @currentIds;

    SET @ddl = CONCAT('UPDATE background_transfer_partitions SET current_sid = NULL WHERE current_sid IS NOT NULL AND current_sid NOT IN (',@currentIds,');');
    PREPARE stmt FROM @ddl;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    SET @ddl = CONCAT('UPDATE background_transfer_tables SET current_sid = NULL WHERE current_sid IS NOT NULL AND current_sid NOT IN (',@currentIds,');');
    PREPARE stmt FROM @ddl;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    CALL background_transfer_in_progress(@background_in_progress);

    IF (@background_in_progress)
    THEN
        CALL background_update_id(@current_update_id);

        SET OUT_status=1;

        IF EXISTS (SELECT setting_value FROM background_transfer_settings WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION')
        THEN
            SELECT setting_value FROM background_transfer_settings WHERE update_id=@current_update_id AND setting_key='BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION' INTO min_duration;

            SELECT ADDDATE(now(), INTERVAL min_duration SECOND) INTO target_date;

            IF (target_date IS NOT NULL)
            THEN
                WHILE ((now()<target_date) AND (OUT_status=1)) DO
                    CALL background_transfer_increment(
                        @current_update_id,
                        OUT_status,
                        OUT_message);
                END WHILE;
            END IF;
        END IF;
    END IF;
END $$
DELIMITER ;

DROP PROCEDURE IF EXISTS background_transfer_force_splitlot;
DELIMITER $$
CREATE PROCEDURE background_transfer_force_splitlot(
    IN  IN_table_name VARCHAR(65),
    IN  IN_splitlot_id INT,
    OUT OUT_status INT,
    OUT OUT_message TEXT
)
force_label:BEGIN
    DECLARE splitlot_increment INT;
    DECLARE current_update_id INT;
    DECLARE partition_found TINYINT DEFAULT 0;
    DECLARE current_partition_name VARCHAR(65);
    DECLARE current_partition_status VARCHAR(45);
    DECLARE active_thread TINYINT;
    DECLARE current_processed_splitlot INT;
    DECLARE loop_count INT DEFAULT 0;

    -- Get the correct update_id
    SELECT
        update_id
    FROM
        background_transfer_tables
    WHERE
        table_name = IN_table_name
        AND status <> 'DONE'
    ORDER BY
        update_id ASC
    LIMIT 1
    INTO
        current_update_id;

    -- Get the splitlot increment
    SELECT
        IFNULL(setting_value, 10)
    FROM
        background_transfer_settings
    WHERE
        update_id=current_update_id
        AND setting_key='BACKGROUND_TRANSFER_INCREMENT'
    LIMIT 1
    INTO
        splitlot_increment;

    -- Locate the partition which includes the requested splitlot
    SELECT
        1,
        partition_name,
        status,
        IF(current_sid IS NULL, 0, 1),
        current_index
    FROM
        background_transfer_partitions
    WHERE
        update_id = current_update_id
        AND table_name = IN_table_name
        AND min_index <= IN_splitlot_id
        AND max_index >= IN_splitlot_id
    LIMIT 1
    INTO
        partition_found,
        current_partition_name,
        current_partition_status,
        active_thread,
        current_processed_splitlot;

    SET OUT_status = 0;
    SET OUT_message = 'Required splitlot not part of the background update process';

  -- And process the splitlot if is has been found
  IF (partition_found = 1) THEN
    IF (
      current_partition_status = 'DONE'
            OR (
        current_partition_status = 'IN PROGRESS'
                AND (current_processed_splitlot < IN_splitlot_id)
            )
    ) THEN
      -- If the splitlot is already processed, nothing to do
      SET OUT_status = 1;
            SET OUT_message = 'Nothing to do';
    ELSEIF (
      current_partition_status = 'TODO'
            OR (
        current_partition_status = 'IN PROGRESS'
                AND (
          active_thread = 0
                    OR (current_processed_splitlot - splitlot_increment > IN_splitlot_id)
        )
            )
        ) THEN
      -- If the splitlot has not already been transferred,
      -- force the transfer
      CALL background_transfer_copy_data(
        current_update_id,
        IN_table_name,
        CONCAT(IN_table_name, '_background'),
        IN_splitlot_id,
        IN_splitlot_id,
        OUT_status,
        OUT_message
      );
            IF (OUT_status = 1) THEN
        SET OUT_message = 'Successfully transfered';
      END IF;
        ELSEIF (current_partition_status = 'IN PROGRESS') THEN
      -- If the splitlot is currently being processed, wait for the end of the process
      -- loop the loop
            WHILE NOT EXISTS (
        SELECT
          current_index
        FROM
          background_transfer_partitions
        WHERE
          update_id = current_update_id
                    AND table_name = IN_table_name
                    AND partition_name = current_partition_name
                    AND (
            current_index < IN_splitlot_id
            OR current_sid IS NULL
          )

            ) AND (loop_count < 10) DO
        SET loop_count = loop_count + 1;
        SELECT SLEEP(1);
      END WHILE;

      IF (loop_count >= 10) THEN
        SET OUT_status = 0;
        SET OUT_message = 'The regular background update is taking too long to proceed its increment, please try again later';
            ELSEIF NOT EXISTS (
        SELECT
          current_index
        FROM
          background_transfer_partitions
        WHERE
          update_id = current_update_id
                    AND table_name = IN_table_name
                    AND partition_name = current_partition_name
                    AND current_index < IN_splitlot_id
      ) THEN
        SET OUT_status = 0;
        SET OUT_message = 'The regular background update encountered an error during the splitlot processing';
      ELSE
        SET OUT_status = 1;
        SET OUT_message = 'Splitlot processed by the regular background update';
            END IF;
    ELSE
      SET OUT_status = 0;
            SET OUT_message = 'Unexpected situation encountered';
        END IF;
    END IF;
END $$
DELIMITER ;
