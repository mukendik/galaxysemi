-- ---------------------------------------------------------
-- DO NOT EDIT THIS FILE UNLESS: 
-- o To customize the update 
-- o To execute it manually
-- ---------------------------------------------------------

-- ---------------------------------------------------------
-- CAUTION/INFO/QUESTION messages below are not commented to make sure that 
-- scripts are in the right state before to be ran manually
-- ---------------------------------------------------------
CAUTION: When manually running this script, perform the following four steps:
CAUTION: 1. Uncomment the line below and specify a working database.
-- use database_name_xx;
CAUTION: 2. To catch all errors, comment each line "DECLARE EXIT HANDLER FOR SQLEXCEPTION" (if it exists) as shown below:
CAUTION: -- DECLARE EXIT HANDLER FOR SQLEXCEPTION
CAUTION: 3. Before running the first TDR update script, run the script common_update_initialize.sql, then tdr_update_initialize.sql.
CAUTION: 4. After running the last TDR update script, run the script tdr_update_finalize.sql, then common_update_finalize.sql.

INFO: *** RESULTS TABLES ENHANCEMENT ***
INFO:This TDR update performs normal updates and adds a new RESULT_FLAGS columns info to the RESULTS tables. To minimize downtime while the TDR is being updated, this update process transfers data in the biggest tables in a background thread while resuming data insertion in parallel. 
INFO:
INFO:For the "biggest tables" identified in a gexdb_mysql_update_b74_to_b75.sql file for the background transfer:
INFO: - the table name has '_background' appended to it;
INFO: - a new empty table is generated with the same structure than the original '_background' table;
INFO: - new columns are added to the new empty table.
INFO: - the new empty table is updated with data from the original '_background' table in a background thread;
INFO:
INFO:Tables that are not identified in the background update are updated in the normal way (alter table).
INFO: 
INFO:The new background transfer capability can be customized by editing the 'BACKGROUND TRANSFER OPTIONS' section in <installation dir>/install/mysql/gexdb_mysql_update_b73_to_b74.sql.
INFO:To change the default options for the TDR update, edit this file, and save it before starting the TDR update by clicking the 'Yes' button below.
INFO: 
QUESTION: Continue the update?

-- ---------------------------------------------------------
-- START UPDATE
-- ---------------------------------------------------------
-- it is allowed to update a TDR even if a previous background transfer is in progress
-- but only if no collision
-- give here the list of tables that need to be updated
CALL check_table_for_update('ft_ptest_results', @status, @message);
CALL check_table_for_update('ft_mptest_results', @status, @message);
CALL check_table_for_update('ft_ftest_results', @status, @message);
CALL check_table_for_update('et_ptest_results', @status, @message);
CALL check_table_for_update('wt_ptest_results', @status, @message);
CALL check_table_for_update('wt_mptest_results', @status, @message);
CALL check_table_for_update('wt_ftest_results', @status, @message);
CALL check_table_for_update('ft_ptest_info', @status, @message);
CALL check_table_for_update('ft_mptest_info', @status, @message);
CALL check_table_for_update('et_ptest_info', @status, @message);
CALL check_table_for_update('wt_ptest_info', @status, @message);
CALL check_table_for_update('wt_mptest_info', @status, @message);
CALL check_table_for_update('ft_splitlot', @status, @message);
CALL check_table_for_update('et_splitlot', @status, @message);
CALL check_table_for_update('wt_splitlot', @status, @message);
CALL check_table_for_update('ft_sublot_info', @status, @message);
CALL check_table_for_update('et_wafer_info', @status, @message);
CALL check_table_for_update('wt_wafer_info', @status, @message);
CALL check_table_for_update('ft_lot', @status, @message);
CALL check_table_for_update('et_lot', @status, @message);
CALL check_table_for_update('wt_lot', @status, @message);
CALL check_table_for_update('ft_prod_alarm', @status, @message);
CALL check_table_for_update('et_prod_alarm', @status, @message);
CALL check_table_for_update('wt_prod_alarm', @status, @message);


-- Check if the current TDR version is compatible with this update
-- This new version allow to update the TDR even if some background transfer still running
CALL is_compatible_version(74, @status, @message);
CALL start_update('TDR V7.01 B75 (MySQL)', 701, 75, @status, @message);
CALL add_status('UPDATING_INDEXES', @status, @message);

-- ---------------------------------------------------------
-- BACKGROUND TRANSFER OPTIONS
-- ---------------------------------------------------------
-- HERE THE OPTIONS FOR THE BACKGROUND UPDATE
-- MUST CONTAIN ONLY TABLES WITH splitlot_id COLUMN
-- CAN BE MODIFIED

-- Following default settings activate the background transfer for run and results tables,
-- and transfers 1 week old data for these tables before starting the background transfer.

-- Option BACKGROUND_TRANSFER: enables or disables the background transfer
-- possible values: ENABLED | DISABLED
-- default value: ENABLED
CALL background_transfer_add_settings('BACKGROUND_TRANSFER','ENABLED', @status, @message);

-- Option BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION: minimum duration (in seconds) of 1 transfer step.
--   Makes sure a transfer step run at least this amount of time, even if the number of splitlot defined
--   by BACKGROUND_TRANSFER_INCREMENT is already reached.
-- possible values: unsigned integer > 1
-- default value: 600
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION','600', @status, @message);

-- Option BACKGROUND_TRANSFER_SCHEDULER_FREQUENCY: frequency at which the background transfer event is triggered to execute one transfer step.
-- possible values: <value> <unit> with <value> unsigned integer > 1 and <unit> in [YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND]
-- default value: 10 SECOND
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_SCHEDULER_FREQUENCY','10 SECOND', @status, @message);

-- Option BACKGROUND_TRANSFER_INCREMENT: nb. of splitlots to transfer during one table transfer step.
-- possible values: unsigned integer > 1
-- default value: 1000
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_INCREMENT','1000', @status, @message);

-- Option BACKGROUND_TRANSFER_MAX_THREADS: nb. of authorised parallel threads.
-- possible values: unsigned integer >= 1
-- default value: 10
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_MAX_THREADS','10', @status, @message);

-- Option TABLE: list of tables for the background update
--   Add all high-volume tables you consider time consumming for the update
CALL background_transfer_add_settings('TABLE','ft_ptest_results' , @status, @message);
CALL background_transfer_add_settings('TABLE','ft_mptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','ft_ftest_results' , @status, @message);
CALL background_transfer_add_settings('TABLE','et_ptest_results' , @status, @message);
CALL background_transfer_add_settings('TABLE','wt_ptest_results' , @status, @message);
CALL background_transfer_add_settings('TABLE','wt_mptest_results', @status, @message);
CALL background_transfer_add_settings('TABLE','wt_ftest_results' , @status, @message);

-- ---------------------------------------------------------
-- END OF BACKGROUND TRANSFER OPTIONS
-- ---------------------------------------------------------
CALL background_transfer_check_settings(@status, @message);

-- Prepare the BackGround update
CALL background_transfer_initialization(@status, @message);

-- ---------------------------------------------------------
-- UPDATE DATA
-- ---------------------------------------------------------
-- IF THE UPDATE WAS ALREADY EXECUTED, NEED TO USE THE ADEQUAT COLUMN NAME
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='ft_ptest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('ft_ptest_results' ,'result_flags',@column_name, @status, @message);
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='ft_mptest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('ft_mptest_results' ,'result_flags',@column_name, @status, @message);
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='ft_ftest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('ft_ftest_results' ,'result_flags',@column_name, @status, @message);
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='et_ptest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('et_ptest_results' ,'result_flags',@column_name, @status, @message);
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='wt_ptest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('wt_ptest_results' ,'result_flags',@column_name, @status, @message);
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='wt_mptest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('wt_mptest_results' ,'result_flags',@column_name, @status, @message);
SELECT IF(column_name='flags','ASCII(flags)','result_flags') FROM information_schema.COLUMNS WHERE column_name LIKE '%flags' AND table_name='wt_ftest_results' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('wt_ftest_results' ,'result_flags',@column_name, @status, @message);

-- REMOVE THE TRANSFER OF ALL DEPRECATED COLUMNS
CALL background_transfer_add_custom_transfer_description('ft_ptest_results' ,'flags','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_mptest_results','flags','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_ftest_results' ,'flags','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_ptest_results' ,'flags','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ptest_results' ,'flags','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_mptest_results','flags','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_ftest_results'	,'flags','IGNORE', @status, @message);

-- ---------------------------------------------------------
-- REPLACE ALL BINARY DATATYPE WITH A TINYINT FOR MARIADB 10.1.12
-- ---------------------------------------------------------

-- THE GOAL IS TO REPLACE ALL BINARY(1) AND BINARY(2) ON EXISTING TABLES
-- THE UPDATE MUST BE DONE IN 3 STEPS
-- * CREATE A NEW XX_FLAGS TINYINT COLUMN
-- * POPULATE THIS NEW COLUMNS WITH A CONVERTION OF THE VALUE IN THE BINARY FLAGS
-- * REMOVE OLD BINARY FLAGS COLUMN

DROP PROCEDURE IF EXISTS move_binary_data;
DELIMITER $$
CREATE PROCEDURE move_binary_data(
	IN  IN_shema_name text,
	IN  IN_table_name text,
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
       SHOW ERRORS;
       SET OUT_message="Error SQL Exception";
    SET OUT_status=0;

    -- BEFORE TO MOVE THE DATA, CHECK IF THE UPDATE IS NEEDED
    -- CHECK IF THE COLUMN FLAGS STILL EXISTS
    IF EXISTS(SELECT column_name FROM information_schema.columns WHERE table_schema=Database() AND table_name=IN_table_name AND column_name='flags')
    THEN
	    IF (IN_table_name = 'ft_ptest_results') THEN
		    UPDATE ft_ptest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'ft_mptest_results') THEN
		    UPDATE ft_mptest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'ft_ftest_results') THEN
		    UPDATE ft_ftest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'et_ptest_results') THEN
		    UPDATE et_ptest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'wt_ptest_results') THEN
		    UPDATE wt_ptest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'wt_mptest_results') THEN
		    UPDATE wt_mptest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'wt_ftest_results') THEN
		    UPDATE wt_ftest_results SET result_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'wt_wafer_info') THEN
		    UPDATE wt_wafer_info SET wafer_flags=(ASCII(flags)-ASCII(0));
	    END IF;
	    IF (IN_table_name = 'ft_splitlot') THEN
		    UPDATE ft_splitlot SET splitlot_flags=(ASCII(flags)-ASCII(0));
	    END IF;
	    IF (IN_table_name = 'et_splitlot') THEN
		    UPDATE et_splitlot SET splitlot_flags=(ASCII(flags)-ASCII(0));
	    END IF;
	    IF (IN_table_name = 'wt_splitlot') THEN
		    UPDATE wt_splitlot SET splitlot_flags=(ASCII(flags)-ASCII(0));
	    END IF;
	    IF (IN_table_name = 'ft_ptest_info') THEN
		    UPDATE ft_ptest_info SET test_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'ft_mptest_info') THEN
		    UPDATE ft_mptest_info SET test_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'et_ptest_info') THEN
		    UPDATE et_ptest_info SET test_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'wt_ptest_info') THEN
		    UPDATE wt_ptest_info SET test_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'wt_mptest_info') THEN
		    UPDATE wt_mptest_info SET test_flags=ASCII(flags);
	    END IF;
	    IF (IN_table_name = 'ft_prod_alarm') THEN
		    UPDATE ft_prod_alarm SET alarm_flags=(ASCII(flags)-ASCII(0));
	    END IF;
	    IF (IN_table_name = 'et_prod_alarm') THEN
		    UPDATE et_prod_alarm SET alarm_flags=(ASCII(flags)-ASCII(0));
	    END IF;
	    IF (IN_table_name = 'wt_prod_alarm') THEN
		    UPDATE wt_prod_alarm SET alarm_flags=(ASCII(flags)-ASCII(0));
	    END IF;

    END IF;

    SET OUT_status=1;
END $$
DELIMITER ;

-- ---------------------------------------------------------
-- UPDATE XX_XTEST_RESULTS
-- ADD result_flags AT THE END OF THE TABLES
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'ft_ptest_results' , 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_ptest_results' , @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_ptest_results' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_mptest_results', 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_mptest_results', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_mptest_results', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_ftest_results' , 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_ftest_results' , @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_ftest_results' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_ptest_results' , 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'et_ptest_results' , @status, @message);
CALL drop_column_if_exists(   Database(), 'et_ptest_results' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_ptest_results' , 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_ptest_results' , @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_ptest_results' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_mptest_results', 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_mptest_results', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_mptest_results', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_ftest_results' , 'result_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: PASS, BIT2: INVALID_RESULT, BIT3: NOTEXECUTED, BIT4:INVALID_PASSFLAG, BIT5: ALARM\' AFTER `testseq`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_ftest_results' , @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_ftest_results' , 'flags', @status, @message);

-- ---------------------------------------------------------
-- UPDATE XX_LOT
-- ADD lot_flags AT THE END OF THE TABLES
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'ft_lot', 'lot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'not currently in use\'', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_lot', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_lot', 'lot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'not currently in use\'', @status, @message);
CALL drop_column_if_exists(   Database(), 'et_lot', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_lot', 'lot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'not currently in use\'', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_lot', 'flags', @status, @message);

-- ---------------------------------------------------------
-- UPDATE XX_WAFER_INFO/XX_SUBLOT_INFO
-- ADD wafer_flags/sublot_flags AFTER THE nb_parts_good OF THE TABLES
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'ft_sublot_info', 'sublot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'not currently in use\' AFTER `nb_parts_good`', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_sublot_info', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_wafer_info' , 'wafer_flags' , 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'not currently in use\' AFTER `nb_parts_good`', @status, @message);
CALL drop_column_if_exists(   Database(), 'et_wafer_info' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_wafer_info' , 'wafer_flags' , 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: GROSSDIE OVERLOADED \' AFTER `nb_parts_good`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_wafer_info' , @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_wafer_info' , 'flags', @status, @message);

-- ---------------------------------------------------------
-- UPDATE XX_SPLITLOT
-- ADD splitlot_flags BEFORE THE nb_parts OF THE TABLES
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'ft_splitlot', 'splitlot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: TEST SUMMARY, BIT2: NO TEST RESULTS, BIT3: PARTS FROM SAMPLES\' AFTER `tester_type`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_splitlot', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_splitlot', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_splitlot', 'splitlot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: TEST SUMMARY, BIT2: NO TEST RESULTS, BIT3: PARTS FROM SAMPLES\' AFTER `tester_type`', @status, @message);
CALL move_binary_data(   	  Database(), 'et_splitlot', @status, @message);
CALL drop_column_if_exists(   Database(), 'et_splitlot', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_splitlot', 'splitlot_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: TEST SUMMARY, BIT2: NO TEST RESULTS, BIT3: PARTS FROM SAMPLES\' AFTER `tester_type`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_splitlot', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_splitlot', 'flags', @status, @message);

-- ---------------------------------------------------------
-- UPDATE XX_XTEST_INFO
-- ADD test_flags AFTER THE units OF THE TABLES
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'ft_ptest_info' , 'test_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: MULTIPLE_LIMIT_SET, BIT2: LL_STRICT, BIT3: HL_STRICT, BIT4:PAT_ACTIVE\' AFTER `units`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_ptest_info' , @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_ptest_info' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_mptest_info', 'test_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: MULTIPLE_LIMIT_SET, BIT2: LL_STRICT, BIT3: HL_STRICT, BIT4:PAT_ACTIVE\' AFTER `units`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_mptest_info', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_mptest_info', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_ptest_info' , 'test_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: MULTIPLE_LIMIT_SET, BIT2: LL_STRICT, BIT3: HL_STRICT, BIT4:PAT_ACTIVE\' AFTER `units`', @status, @message);
CALL move_binary_data(   	  Database(), 'et_ptest_info' , @status, @message);
CALL drop_column_if_exists(   Database(), 'et_ptest_info' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_ptest_info' , 'test_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: MULTIPLE_LIMIT_SET, BIT2: LL_STRICT, BIT3: HL_STRICT, BIT4:PAT_ACTIVE\' AFTER `units`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_ptest_info' , @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_ptest_info' , 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_mptest_info', 'test_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: MULTIPLE_LIMIT_SET, BIT2: LL_STRICT, BIT3: HL_STRICT, BIT4:PAT_ACTIVE\' AFTER `units`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_mptest_info', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_mptest_info', 'flags', @status, @message);

-- ---------------------------------------------------------
-- UPDATE XX_PROD_ALARM
-- ADD alarm_flags AFTER THE item_name OF THE TABLES
-- ---------------------------------------------------------
CALL add_column_if_not_exists(Database(), 'ft_prod_alarm', 'alarm_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'\' AFTER `item_name`', @status, @message);
CALL move_binary_data(   	  Database(), 'ft_prod_alarm', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_prod_alarm', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_prod_alarm', 'alarm_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'\' AFTER `item_name`', @status, @message);
CALL move_binary_data(   	  Database(), 'et_prod_alarm', @status, @message);
CALL drop_column_if_exists(   Database(), 'et_prod_alarm', 'flags', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_prod_alarm', 'alarm_flags', 'tinyint(2) unsigned NOT NULL DEFAULT 0 COMMENT \'\' AFTER `item_name`', @status, @message);
CALL move_binary_data(   	  Database(), 'wt_prod_alarm', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_prod_alarm', 'flags', @status, @message);


-- ---------------------------------------------------------
-- DROP INDEX ON RUN TABLES
-- ---------------------------------------------------------
CALL drop_index_to(Database(), 'ft_run', 'site_no', @status, @message);
CALL drop_index_to(Database(), 'ft_run', 'part_x,part_y', @status, @message);
CALL drop_index_to(Database(), 'ft_run', 'part_id', @status, @message);
CALL drop_index_to(Database(), 'ft_run', 'part_status', @status, @message);
CALL drop_index_to(Database(), 'ft_run', 'intermediate', @status, @message);
CALL drop_index_to(Database(), 'ft_run', 'final', @status, @message);
CALL drop_index_to(Database(), 'ft_run', 'hbin_no,sbin_no', @status, @message);

CALL drop_index_to(Database(), 'et_run', 'site_no', @status, @message);
CALL drop_index_to(Database(), 'et_run', 'part_x,part_y', @status, @message);
CALL drop_index_to(Database(), 'et_run', 'part_id', @status, @message);
CALL drop_index_to(Database(), 'et_run', 'part_status', @status, @message);
CALL drop_index_to(Database(), 'et_run', 'intermediate', @status, @message);
CALL drop_index_to(Database(), 'et_run', 'final', @status, @message);
CALL drop_index_to(Database(), 'et_run', 'hbin_no,sbin_no', @status, @message);

CALL drop_index_to(Database(), 'wt_run', 'site_no', @status, @message);
CALL drop_index_to(Database(), 'wt_run', 'part_x,part_y', @status, @message);
CALL drop_index_to(Database(), 'wt_run', 'part_id', @status, @message);
CALL drop_index_to(Database(), 'wt_run', 'part_status', @status, @message);
CALL drop_index_to(Database(), 'wt_run', 'intermediate', @status, @message);
CALL drop_index_to(Database(), 'wt_run', 'final', @status, @message);
CALL drop_index_to(Database(), 'wt_run', 'hbin_no,sbin_no', @status, @message);


-- ---------------------------------------------------------
-- CHECK UPDATE DATA PROCEDURE
-- ---------------------------------------------------------

DROP PROCEDURE IF EXISTS update_data;
DELIMITER $$
CREATE PROCEDURE update_data(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
       SET OUT_message="Error SQL Exception";
    SET OUT_status=0;


    SET OUT_status=1;
END $$
DELIMITER ;
CALL update_data(@status, @message);
DROP PROCEDURE update_data;
DROP PROCEDURE move_binary_data;

WARNING: To finalize the BackGround Transfer, you need to activate it into your HouseKeeping GUI - section 'BackGround Update'. 

-- ---------------------------------------------------------
-- STOP UPDATE
-- ---------------------------------------------------------
CALL stop_update(@status, @message);
