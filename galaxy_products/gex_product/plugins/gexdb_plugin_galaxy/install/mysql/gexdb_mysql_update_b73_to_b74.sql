-- ---------------------------------------------------------
-- DO NOT EDIT THIS FILE UNLESS: 
-- o To customize the update 
-- o To execute it manually
-- ---------------------------------------------------------

-- ---------------------------------------------------------
-- CAUTION/INFO/QUESTION messages below are not commented to make sure that 
-- scripts are in the right state before to be ran manually
-- ---------------------------------------------------------
CAUTION: When manually running this script, perform the following four steps:
CAUTION: 1. Uncomment the line below and specify a working database.
-- use database_name_xx;
CAUTION: 2. To catch all errors, comment each line "DECLARE EXIT HANDLER FOR SQLEXCEPTION" (if it exists) as shown below:
CAUTION: -- DECLARE EXIT HANDLER FOR SQLEXCEPTION
CAUTION: 3. Before running the first TDR update script, run the script common_update_initialize.sql, then tdr_update_initialize.sql.
CAUTION: 4. After running the last TDR update script, run the script tdr_update_finalize.sql, then common_update_finalize.sql.

INFO: *** RUN TABLES ENHANCEMENT ***
INFO:This TDR update performs normal updates and adds new columns info to the RUN tables. To minimize downtime while the TDR is being updated, this update process transfers data in the biggest tables in a background thread while resuming data insertion in parallel. 
INFO:
INFO:For the "biggest tables" identified in a gexdb_mysql_update_b73_to_b74.sql file for the background transfer:
INFO: - the table name has '_background' appended to it;
INFO: - a new empty table is generated from the original '_background' table;
INFO: - the new empty table has the same structure as the original '_background' table;
INFO: - new columns are added to the new empty table.
INFO: - the new empty table is updated with data from the original '_background' table in a background thread;
INFO:
INFO:Tables that are not identified in the background update are updated in the normal way (alter table).
INFO:
INFO:The new background transfer capability can be customized by editing the 'BACKGROUND TRANSFER OPTIONS' section in <installation dir>/install/mysql/gexdb_mysql_update_b73_to_b74.sql.
INFO:To change the default options for the TDR update, edit this file, and save it before starting the TDR update by clicking the 'Yes' button below.
INFO: 
QUESTION: Continue the update?

INFO: *** ADR CONSOLIDATION ENHANCEMENT ***
INFO:The update of the new BOOLEAN fields 'INTERMEDIATE' and 'FINAL' in the RUN tables will be done during the CONSOLIDATION process. Those fields are MANDATORY for CONSOLIDATED extraction to populate the ADR statistics. 
INFO:
INFO:To activate this new features on existing data, it is MANDATORY to restart a CONSOLIDATION cycle:
INFO: - you need to manually flag the existing data for CONSOLIDATION:
INFO: - or uncomment the line in the following stored procedure UPDATE_DATA()
INFO:
INFO:Lots that are not identified for this new process will not have any CONSOLIDATED results statistics in the ADR.
INFO: 
QUESTION: Continue the update?


-- ---------------------------------------------------------
-- START UPDATE
-- ---------------------------------------------------------
CALL is_compatible_version(73, @status, @message);
CALL start_update('TDR V7.00 B74 (MySQL)', 700, 74, @status, @message);
CALL add_status('UPDATING_INDEXES', @status, @message);

-- ---------------------------------------------------------
-- BACKGROUND TRANSFER OPTIONS
-- ---------------------------------------------------------
-- HERE THE OPTIONS FOR THE BACKGROUND UPDATE
-- MUST CONTAIN ONLY TABLES WITH splitlot_id COLUMN
-- CAN BE MODIFIED

-- Following default settings activate the background transfer for run and results tables,
-- and transfers 1 week old data for these tables before starting the background transfer.

-- Option BACKGROUND_TRANSFER: enables or disables the background transfer
-- possible values: ENABLED | DISABLED
-- default value: ENABLED
CALL background_transfer_add_settings('BACKGROUND_TRANSFER','ENABLED', @status, @message);

-- Option BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION: minimum duration (in seconds) of 1 transfer step.
--   Makes sure a transfer step run at least this amount of time, even if the number of splitlot defined
--   by BACKGROUND_TRANSFER_INCREMENT is already reached.
-- possible values: unsigned integer > 1
-- default value: 60
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_STEP_MINIMUM_DURATION','60', @status, @message);

-- Option BACKGROUND_TRANSFER_SCHEDULER_FREQUENCY: frequency at which the background transfer event is triggered to execute one transfer step.
-- possible values: <value> <unit> with <value> unsigned integer > 1 and <unit> in [YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND]
-- default value: 60 SECOND
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_SCHEDULER_FREQUENCY','10 SECOND', @status, @message);

-- Option BACKGROUND_TRANSFER_INCREMENT: nb. of splitlots to transfer during one table transfer step.
-- possible values: unsigned integer > 1
-- default value: 100
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_INCREMENT','1000', @status, @message);

-- Option BACKGROUND_TRANSFER_MAX_THREADS: nb. of authorised parallel threads.
-- possible values: unsigned integer >= 1
-- default value: 1
CALL background_transfer_add_settings('BACKGROUND_TRANSFER_MAX_THREADS','10', @status, @message);

-- Option TABLE: list of tables for the background update
--   Add all high-volume tables you consider time consumming for the update
CALL background_transfer_add_settings('TABLE','ft_run', @status, @message);
CALL background_transfer_add_settings('TABLE','et_run', @status, @message);
CALL background_transfer_add_settings('TABLE','wt_run', @status, @message);

-- ---------------------------------------------------------
-- END OF BACKGROUND TRANSFER OPTIONS
-- ---------------------------------------------------------
CALL background_transfer_check_settings(@status, @message);

-- Prepare the BackGround update
CALL background_transfer_initialization(@status, @message);

-- ---------------------------------------------------------
-- UPDATE DATA
-- ---------------------------------------------------------
-- THE FIRST/LAST TEST FAIL CANNOT BE UPDATED THROUGH THE BACKGROUND PROCESS
-- THIS IS THE CONSOLIDATION PROCESS THAT WILL CHECK IF THE RUN TABLE NEED TO BE UPDATED
-- TO FINALIZE THE UPDATE OF THE RUN TABLE, FLAG THE SPLITLOT TABLE WITH BINNING_CONSOLIDATION
CALL background_transfer_add_custom_transfer_description('ft_run','part_flags','0', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','part_flags','0', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','part_flags','0', @status, @message);

CALL background_transfer_add_custom_transfer_description('ft_run','part_status','IFNULL(part_status,"")', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','part_status','IFNULL(part_status,"")', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','part_status','IFNULL(part_status,"")', @status, @message);

-- IF THE UPDATE WAS ALREADY EXECUTED, NEED TO USE THE ADEQUAT COLUMN NAME
SELECT column_name FROM information_schema.COLUMNS WHERE column_name LIKE '%retest_index' AND table_name='ft_run' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('ft_run','part_retest_index',@column_name, @status, @message);
SELECT column_name FROM information_schema.COLUMNS WHERE column_name LIKE '%retest_index' AND table_name='wt_run' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('wt_run','part_retest_index',@column_name, @status, @message);
SELECT column_name FROM information_schema.COLUMNS WHERE column_name LIKE '%retest_index' AND table_name='et_run' AND table_schema=Database() INTO @column_name;
CALL background_transfer_add_custom_transfer_description('et_run','part_retest_index',@column_name, @status, @message);

-- REMOVE THE TRANSFER OF ALL DEPRECATED COLUMNS
CALL background_transfer_add_custom_transfer_description('ft_run','retest_index','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','retest_index','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','retest_index','IGNORE', @status, @message);

CALL background_transfer_add_custom_transfer_description('ft_run','firstfail_tnum','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','firstfail_tnum','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','firstfail_tnum','IGNORE', @status, @message);

CALL background_transfer_add_custom_transfer_description('ft_run','firstfail_tname','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','firstfail_tname','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','firstfail_tname','IGNORE', @status, @message);

-- REMOVE THE TRANSFER ALL NEW COLUMNS
CALL background_transfer_add_custom_transfer_description('ft_run','intermediate','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_run','final','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_run','firstfail_test_type','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_run','firstfail_test_id','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_run','lastfail_test_type','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('ft_run','lastfail_test_id','IGNORE', @status, @message);

CALL background_transfer_add_custom_transfer_description('wt_run','intermediate','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','final','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','firstfail_test_type','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','firstfail_test_id','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','lastfail_test_type','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('wt_run','lastfail_test_id','IGNORE', @status, @message);

CALL background_transfer_add_custom_transfer_description('et_run','intermediate','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','final','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','firstfail_test_type','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','firstfail_test_id','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','lastfail_test_type','IGNORE', @status, @message);
CALL background_transfer_add_custom_transfer_description('et_run','lastfail_test_id','IGNORE', @status, @message);

-- ---------------------------------------------------------
-- ENHANCEMENT FOR RUNS AND RUNS CONSOLIDATION
-- ---------------------------------------------------------

--
-- Table structure for table et_run_consolidation
--

-- THE GOAL IS TO CREATE THE NEW RUN_CONSOLIDATION TABLE WITH THE EXISTING STRUCTURE FROM THE RUN TABLE
-- * PARTITIONS
-- * INDEXES
-- Create consolidation table structure with index and partition from existing run table
-- ---------------------------------------------------------
-- UPDATE XX_RUN
-- ---------------------------------------------------------
DROP TABLE IF EXISTS et_run_consolidation;
DROP TABLE IF EXISTS wt_run_consolidation;
DROP TABLE IF EXISTS ft_run_consolidation;

CALL rename_column(           Database(), 'et_run', 'retest_index', 'part_retest_index', @status, @message);
CALL modify_column(           Database(), 'et_run', 'part_retest_index', 'tinyint(3) unsigned NOT NULL DEFAULT 0 COMMENT \'index of the die test (0) or retest (1+) status\' AFTER `part_y`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'part_flags', 'tinyint(1) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: part retested, BIT2: no full touchdown\' AFTER `part_status`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'intermediate', 'tinyint(1) unsigned NULL DEFAULT NULL COMMENT \'BOOLEAN: identification of  the die for the consolidated test_insertion\' AFTER `part_flags`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'final', 'tinyint(1) unsigned NULL DEFAULT NULL COMMENT \'BOOLEAN: identification of  the die for the consolidated test_flow\' AFTER `intermediate`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'firstfail_test_type', 'char(1) DEFAULT NULL COMMENT \'identification of the first test failed on that die\' AFTER `tests_failed`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'firstfail_test_id', 'smallint(5) unsigned DEFAULT NULL COMMENT \'identification of the first test failed on that die\' AFTER `firstfail_test_type`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'lastfail_test_type', 'char(1) DEFAULT NULL COMMENT \'identification of the last test failed on that die\' AFTER `firstfail_test_id`', @status, @message);
CALL add_column_if_not_exists(Database(), 'et_run', 'lastfail_test_id', 'smallint(5) unsigned DEFAULT NULL COMMENT \'identification of the last test failed on that die\' AFTER `lastfail_test_type`', @status, @message);
CALL drop_column_if_exists(   Database(), 'et_run', 'firstfail_tnum', @status, @message);
CALL drop_column_if_exists(   Database(), 'et_run', 'firstfail_tname', @status, @message);

CALL rename_column(           Database(), 'wt_run', 'retest_index', 'part_retest_index', @status, @message);
CALL modify_column(           Database(), 'wt_run', 'part_retest_index', 'tinyint(3) unsigned NOT NULL DEFAULT 0 COMMENT \'index of the die test (0) or retest (1+) status\' AFTER `part_y`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'part_flags', 'tinyint(1) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: part retested, BIT2: no full touchdown\' AFTER `part_status`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'intermediate', 'tinyint(1) unsigned NULL DEFAULT NULL COMMENT \'BOOLEAN: identification of  the die for the consolidated test_insertion\' AFTER `part_flags`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'final', 'tinyint(1) unsigned NULL DEFAULT NULL COMMENT \'BOOLEAN: identification of  the die for the consolidated test_flow\' AFTER `intermediate`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'firstfail_test_type', 'char(1) DEFAULT NULL COMMENT \'identification of the first test failed on that die\' AFTER `tests_failed`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'firstfail_test_id', 'smallint(5) unsigned DEFAULT NULL COMMENT \'identification of the first test failed on that die\' AFTER `firstfail_test_type`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'lastfail_test_type', 'char(1) DEFAULT NULL COMMENT \'identification of the last test failed on that die\' AFTER `firstfail_test_id`', @status, @message);
CALL add_column_if_not_exists(Database(), 'wt_run', 'lastfail_test_id', 'smallint(5) unsigned DEFAULT NULL COMMENT \'identification of the last test failed on that die\' AFTER `lastfail_test_type`', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_run', 'firstfail_tnum', @status, @message);
CALL drop_column_if_exists(   Database(), 'wt_run', 'firstfail_tname', @status, @message);

CALL rename_column(           Database(), 'ft_run', 'retest_index', 'part_retest_index', @status, @message);
CALL modify_column(           Database(), 'ft_run', 'part_retest_index', 'tinyint(3) unsigned NOT NULL DEFAULT 0 COMMENT \'index of the die test (0) or retest (1+) status\' AFTER `part_y`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'part_flags', 'tinyint(1) unsigned NOT NULL DEFAULT 0 COMMENT \'BIT1: part retested, BIT2: no full touchdown\' AFTER `part_status`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'intermediate', 'tinyint(1) unsigned NULL DEFAULT NULL COMMENT \'BOOLEAN: identification of  the die for the consolidated test_insertion\' AFTER `part_flags`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'final', 'tinyint(1) unsigned NULL DEFAULT NULL COMMENT \'BOOLEAN: identification of  the die for the consolidated test_flow\' AFTER `intermediate`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'firstfail_test_type', 'char(1) DEFAULT NULL COMMENT \'identification of the first test failed on that die\' AFTER `tests_failed`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'firstfail_test_id', 'smallint(5) unsigned DEFAULT NULL COMMENT \'identification of the first test failed on that die\' AFTER `firstfail_test_type`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'lastfail_test_type', 'char(1) DEFAULT NULL COMMENT \'identification of the last test failed on that die\' AFTER `firstfail_test_id`', @status, @message);
CALL add_column_if_not_exists(Database(), 'ft_run', 'lastfail_test_id', 'smallint(5) unsigned DEFAULT NULL COMMENT \'identification of the last test failed on that die\' AFTER `lastfail_test_type`', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_run', 'firstfail_tnum', @status, @message);
CALL drop_column_if_exists(   Database(), 'ft_run', 'firstfail_tname', @status, @message);


-- ---------------------------------------------------------
-- CHECK UPDATE DATA PROCEDURE
-- ---------------------------------------------------------

DROP PROCEDURE IF EXISTS update_data;
DELIMITER $$
CREATE PROCEDURE update_data(
    OUT OUT_status SMALLINT(1),
    OUT OUT_message text)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
       SET OUT_message="Error SQL Exception";
    SET OUT_status=0;

    -- Initialize the new incremental_update key for BIN_STATS and TEST_STATS
    DELETE FROM incremental_update WHERE db_update_name='BIN_STATS' OR db_update_name='TEST_STATS';
    INSERT INTO incremental_update (db_update_name, status) VALUES('BIN_STATS','ENABLED'),('TEST_STATS','DISABLED');

    -- UPDATE FT_SPLITLOT SET incremental_update=IF(incremental_update='' OR incremental_update IS NULL,'BINNING_CONSOLIDATION',CONCAT(incremental_update,'|BINNING_CONSOLIDATION')) WHERE valid_splitlot='Y' AND (incremental_update='' OR incremental_update IS NULL OR incremental_update NOT LIKE '%BINNING_CONSOLIDATION%');
    -- UPDATE WT_SPLITLOT SET incremental_update=IF(incremental_update='' OR incremental_update IS NULL,'BINNING_CONSOLIDATION',CONCAT(incremental_update,'|BINNING_CONSOLIDATION')) WHERE valid_splitlot='Y' AND (incremental_update='' OR incremental_update IS NULL OR incremental_update NOT LIKE '%BINNING_CONSOLIDATION%');
    -- UPDATE ET_SPLITLOT SET incremental_update=IF(incremental_update='' OR incremental_update IS NULL,'BINNING_CONSOLIDATION',CONCAT(incremental_update,'|BINNING_CONSOLIDATION')) WHERE valid_splitlot='Y' AND (incremental_update='' OR incremental_update IS NULL OR incremental_update NOT LIKE '%BINNING_CONSOLIDATION%');

    SET OUT_status=1;
END $$
DELIMITER ;
CALL update_data(@status, @message);
DROP PROCEDURE update_data;

WARNING: To finalize the BackGround Transfer, you need to activate it into your HouseKeeping GUI - section 'BackGround Update'. 

-- ---------------------------------------------------------
-- STOP UPDATE
-- ---------------------------------------------------------
CALL stop_update(@status, @message);
