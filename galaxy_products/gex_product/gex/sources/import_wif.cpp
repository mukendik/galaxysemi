//////////////////////////////////////////////////////////////////////
// import_wif.cpp: Convert a Wif .csv
// file to STDF V4.0
//////////////////////////////////////////////////////////////////////

#include "gqtl_global.h"
#include <qmath.h>

#ifdef _WIN32
#include "windows.h"		// For 'GetWindowsDirectoryA' declaration
#endif

#include <qfileinfo.h>
#include <qregexp.h>
#include <qprogressbar.h>
#include <qapplication.h>
#include <qlabel.h>
#include "engine.h"
#include "import_wif.h"
#include "time.h"
#include "import_constants.h"

// Wif format 1
//Machine ID	NTS00
//Recipe name	Golden Tile.rcp
//Date Time	100528	101537
//			Upper spec	1.50	1.50	1.50	3.00		100.00			100.00			...
//			Lower spec					10.00												...
//DOE	X	Y	rej	ZO-1	ZO-2	ZO-3	Uni	BH	g1p	g1x	g1y	g2p	g2x	g2y	g3p	g3x	g3y	g4p	...
//0	4	0	0	0.30	0.28	0.27	1.57	80.45										...
//1	5	0	0	0.24	0.22	0.15	1.60	78.40										...
//2	6	0	0	0.21	0.16	0.12	1.44	83.92										...


// main.cpp
extern QLabel			*GexScriptStatusLabel;	// Handle to script status text in status bar
extern QProgressBar	*	GexProgressBar;		// Handle to progress bar in status bar


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CGWiftoSTDF::CGWiftoSTDF()
{
	// Default: Wif parameter list on disk includes all known Wif parameters...
	m_bNewWifParameterFound = false;
	m_lStartTime = 0;
	m_strTesterType = "";

	m_pWifParameter = NULL;
}

//////////////////////////////////////////////////////////////////////
// Destruction
//////////////////////////////////////////////////////////////////////
CGWiftoSTDF::~CGWiftoSTDF()
{
	// Destroy list of Parameters tables.
	if(m_pWifParameter!=NULL)
		delete [] m_pWifParameter;
	m_mapWifBinning.clear();
}


//////////////////////////////////////////////////////////////////////
// Get Error
//////////////////////////////////////////////////////////////////////
QString CGWiftoSTDF::GetLastError()
{
	strLastError = "Import Wif: ";

	switch(iLastError)
	{
		default:
		case errNoError:
			strLastError += "No Error";
			break;
		case errOpenFail:
			strLastError += "Failed to open file";
			break;
		case errInvalidFormat:
			strLastError += "Invalid file format";
			break;
		case errInvalidFormatLowInRows:
			strLastError += "Invalid file format: 'Parameter' line too short, missing rows";
			break;
		case errNoLimitsFound:
			strLastError += "Invalid file format: Specification Limits not found";
			break;
		case errWriteSTDF:
			strLastError += "Failed creating temporary file. Folder permission issue?";
			break;	
		case errLicenceExpired:
			strLastError += "License has expired or Data file out of date...";
			break;	
	}
	// Return Error Message
	return strLastError;
}

//////////////////////////////////////////////////////////////////////
// Load Wif Parameter table from DISK
//////////////////////////////////////////////////////////////////////
void CGWiftoSTDF::LoadParameterIndexTable(void)
{
	QString	strWifTableFile;
	QString	strString;

    strWifTableFile  = GS::Gex::Engine::GetInstance().Get("UserFolder").toString();
	strWifTableFile += GEX_WIF_PARAMETERS;

	// Open Wif Parameter table file
	QFile f( strWifTableFile );
    if(!f.open( QIODevice::ReadOnly ))
		return;

	// Assign file I/O stream
	QTextStream hWifTableFile(&f);

	// Skip comment lines
	do
	{
	  strString = hWifTableFile.readLine();
	}
    while((strString.indexOf("----------------------") < 0) && (hWifTableFile.atEnd() == false));

	// Read lines
	m_pFullWifParametersList.clear();
	strString = hWifTableFile.readLine();
	while (strString.isNull() == false)
	{
		// Save Parameter name in list
		m_pFullWifParametersList.append(strString);
		// Read next line
		strString = hWifTableFile.readLine();
	};

	// Close file
	f.close();
}

//////////////////////////////////////////////////////////////////////
// Save Wif Parameter table to DISK
//////////////////////////////////////////////////////////////////////
void CGWiftoSTDF::DumpParameterIndexTable(void)
{
	QString		strWifTableFile;
	int			uIndex;

    strWifTableFile  = GS::Gex::Engine::GetInstance().Get("UserFolder").toString();
	strWifTableFile += GEX_WIF_PARAMETERS;

	// Open Wif Parameter table file
	QFile f( strWifTableFile );
    if(!f.open( QIODevice::WriteOnly ))
		return;

	// Assign file I/O stream
	QTextStream hWifTableFile(&f);

	// First few lines are comments:
	hWifTableFile << "############################################################" << endl;
	hWifTableFile << "# DO NOT EDIT THIS FILE!" << endl;
    hWifTableFile << "# Quantix Examinator: Wif Parameters detected" << endl;
	hWifTableFile << "# www.mentor.com" << endl;
    hWifTableFile << "# Quantix Examinator reads and writes into this file..." << endl;
	hWifTableFile << "-----------------------------------------------------------" << endl;

	// Write lines
	// m_pFullWifParametersList.sort();
	for(uIndex=0;uIndex<m_pFullWifParametersList.count();uIndex++)
	{
		// Write line
		hWifTableFile << m_pFullWifParametersList[uIndex] << endl;
	};

	// Close file
	f.close();
}

//////////////////////////////////////////////////////////////////////
// If Examinator doesn't have this Wif parameter in his dictionnary, have it added.
//////////////////////////////////////////////////////////////////////
void CGWiftoSTDF::UpdateParameterIndexTable(QString strParamName)
{
	// Check if the table is empty...if so, load it from disk first!
	if(m_pFullWifParametersList.isEmpty() == true)
	{
		// Load Wif parameter table from disk...
		LoadParameterIndexTable();
	}
	
	// Check if Parameter name already in table...if not, add it to the list
	// the new full list will be dumped to the disk at the end.
    if(m_pFullWifParametersList.indexOf(strParamName) < 0)
	{
		// Update list
		m_pFullWifParametersList.append(strParamName);

		// Set flag to force the current Wif table to be updated on disk
		m_bNewWifParameterFound = true;
	}
}


//////////////////////////////////////////////////////////////////////
// Check if File is compatible with Wif format
//////////////////////////////////////////////////////////////////////
bool CGWiftoSTDF::IsCompatible(const char *szFileName)
{
	QString strString;

	// Open hCsmFile file
    QFile f( szFileName );
    if(!f.open( QIODevice::ReadOnly ))
	{
		// Failed Opening file
		return false;
	}
	// Assign file I/O stream
	QTextStream hWifFile(&f);

	// Check if first line is the correct Wif header...
	//Machine ID	NTS00
	//Recipe name	Golden Tile.rcp
	//Date Time	100528	101537
	//			Upper spec	1.50	1.50	1.50	3.00		100.00			100.00			...
	//			Lower spec					10.00												...
	//DOE	X	Y	rej	ZO-1	ZO-2	ZO-3	Uni	BH	g1p	g1x	g1y	g2p	g2x	g2y	g3p	g3x	g3y	g4p	...

	int nLine;
	nLine = 0;
	while(!hWifFile.atEnd())
	{
		strString = hWifFile.readLine().simplified().toUpper();
		nLine++;

		if(strString.left(10) == "MACHINE ID")
			continue;
		if(strString.left(11) == "RECIPE NAME")
			continue;
		if(strString.left(9) == "DATE TIME")
			continue;
		if(strString.left(10) == "UPPER SPEC")
			continue;
		if(strString.left(10) == "LOWER SPEC")
			continue;
		if(strString.left(4) == "DOE ")
			break;

		if(nLine > 7)
			break;
	};

	f.close();

	if(strString.left(4) == "DOE ")
	{
		// It's a Wif file
		return true;
	}

	// Incorrect header...this is not a Wif file!
	return false;
}

//////////////////////////////////////////////////////////////////////
// Read and Parse the Wif file
//////////////////////////////////////////////////////////////////////
bool CGWiftoSTDF::ReadWifFile(const char *WifFileName,const char *strFileNameSTDF)
{
	QString strString;
	QString strSection;
	bool	bStatus;
	int		iIndex;				// Loop index

	// Open CSV file
	QFile f( WifFileName );
    if(!f.open( QIODevice::ReadOnly ))
	{
		// Failed Opening Wif file
		iLastError = errOpenFail;
		
		// Convertion failed.
		return false;
	}

 	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	iNextFilePos = 0;
	iProgressStep = 0;
	iFileSize = f.size() + 1;
	

	// Assign file I/O stream
	QTextStream hWifFile(&f);

	m_strWaferID = "1";
	m_lStartTime = m_lStopTime = 0;

	// Wif Naming convention
	//
	//101702409_batchname_CD11T0401Si01_2nd.txt
	QFileInfo clFile(WifFileName);
	strString = clFile.baseName();
	strString = strString.replace(" ","_");
	if(strString.count("_") >= 3)
	{
		// Good naming convention
		// extract info
		int iPos = strString.count("_")-1;

		//�	Wafer ID YYWWTXXXX; YY: year, WW: week, T: Machine ID, XXXX 4-digit rolling number
		//�	Batchname
		//�	Part number
		//�	Reject status

		m_strWaferID = strString.section("_",0,0);
		m_strLotID = strString.section("_",1,iPos-1);
		m_strProductID = strString.section("_",iPos,iPos);
		if(m_strProductID.mid(4,1) == "T")
			m_strTestCode = "TILE wafer";
		else
			m_strTestCode = "FO wafer";

	}



	QDate	clDate;
	QTime	clTime;
	QString strTestsLine;
	QString strUpperLimitsLine;
	QString strLowerLimitsLine;

	// Read Wif information
	while(!hWifFile.atEnd())
	{
		strString = ReadLine(hWifFile);

		strSection = strString.section("\t",0,0).toUpper();

		if(strSection == "DOE")
		{
			// Data
			strTestsLine = strString;
			break;
		}
		else
		if(strSection == "MACHINE ID")
		{
			//Machine ID	NTS00
			m_strTesterID = strString.section("\t",1);
		}
		else
		if(strSection == "RECIPE NAME")
		{
			//Recipe name	Golden Tile.rcp
			m_strAuxFile = strString.section("\t",1);
		}
		else
		if(strSection == "DATE TIME")
		{
			//Date Time	100528	101537
			QString strDate = strString.section("\t",1,1);
			QString strTime = strString.section("\t",2,2);
            clDate.setDate(strDate.left(2).toInt()+2000,strDate.mid(2,2).toInt(),strDate.right(2).toInt());
			clTime.setHMS(strTime.left(2).toInt(),strTime.mid(2,2).toInt(),strTime.right(2).toInt());
		}
		else
		if(strSection.isEmpty()
		&& (strString.indexOf("Upper spec")>0))
		{
			//			Upper spec	1.50	1.50	1.50	3.00		100.00			100.00			...
			strUpperLimitsLine = strString;
		}
		else
		if(strSection.isEmpty()
		&& (strString.indexOf("Lower spec")>0))
		{
			//			Lower spec					10.00												...
			strLowerLimitsLine = strString;
		}
	}

	QDateTime clDateTime(clDate,clTime);
	clDateTime.setTimeSpec(Qt::UTC);
	m_lStartTime = clDateTime.toTime_t();

	//DOE	X	Y	rej
	if(strString.startsWith("DOE	X	Y	rej",Qt::CaseInsensitive))
	{
		m_nPassFailIndex = 3;
		m_iIndexOffset = 4;
	}
	else
	if(strString.startsWith("DOE	rej",Qt::CaseInsensitive))
	{
		m_nPassFailIndex = 1;
		m_iIndexOffset = 2;
	}
	else
	{
		// Incorrect header...this is not a Wif file!
		f.close();
		return false;
	}

    QStringList lstSections = strTestsLine.split("\t", QString::KeepEmptyParts);

	// Count the number of parameters specified in the line
	m_iTotalParameters=lstSections.count();
	// If no parameter specified...ignore!
	if(m_iTotalParameters <= 0)
	{
		// Incorrect header...this is not a valid Wif file!
		iLastError = errInvalidFormat;
		
		// Convertion failed.
		f.close();
		return false;
	}

	// Allocate the buffer to hold the N parameters & results.
	m_pWifParameter = new CGWifParameter[m_iTotalParameters];	// List of parameters

	// Extract the N column names
	// Do not count first m_iIndexOffset fields
	QString strUnit;
  // FIXME: not used ?
  //int nScale;

	for(iIndex=m_iIndexOffset;iIndex<m_iTotalParameters;iIndex++)
	{
		strSection = lstSections[iIndex];
		strUnit = "";
    // FIXME: not used ?
    //nScale = 0;

		if(strSection.isEmpty())
			break;

		UpdateParameterIndexTable(strSection);		// Update Parameter master list if needed.

		m_pWifParameter[iIndex].nNumber = m_pFullWifParametersList.indexOf(strSection);
		m_pWifParameter[iIndex].strName = strSection;
		m_pWifParameter[iIndex].bStaticHeaderWritten = false;
		m_pWifParameter[iIndex].bValidHighLimit = false;
		m_pWifParameter[iIndex].bValidLowLimit = false;
		m_pWifParameter[iIndex].nScale = 0;
		m_pWifParameter[iIndex].fHighLimit = 0.0;
		m_pWifParameter[iIndex].fLowLimit = 0.0;

		// Update Upper limit
		strUnit = strUpperLimitsLine.section("\t",iIndex,iIndex);
		if(!strUnit.isEmpty())
		{
			m_pWifParameter[iIndex].strUnits = strUnit;
			NormalizeValues(m_pWifParameter[iIndex].strUnits,
							m_pWifParameter[iIndex].fHighLimit,
							m_pWifParameter[iIndex].nScale,
							m_pWifParameter[iIndex].bValidHighLimit);
		}

		// Update Lower limit
		strUnit = strLowerLimitsLine.section("\t",iIndex,iIndex);
		if(!strUnit.isEmpty())
		{
			m_pWifParameter[iIndex].strUnits = strUnit;
			NormalizeValues(m_pWifParameter[iIndex].strUnits,
							m_pWifParameter[iIndex].fLowLimit,
							m_pWifParameter[iIndex].nScale,
							m_pWifParameter[iIndex].bValidLowLimit);
		}
        if(QRegExp("(.*\\dx)|(.*\\dy)", Qt::CaseInsensitive).exactMatch(strSection))
			m_pWifParameter[iIndex].strUnits = "Degrees";
		else
        if(QRegExp("(.*\\dp)|(b\\d.*)|(DE)|(BH)|(ZO.*)", Qt::CaseInsensitive).exactMatch(strSection))
			m_pWifParameter[iIndex].strUnits = "%";
	}

	m_iTotalParameters = iIndex;


	// Loop reading file until end is reached & generate STDF file dynamically.
	bStatus = WriteStdfFile(&hWifFile,strFileNameSTDF);
	if(!bStatus)
		QFile::remove(strFileNameSTDF);

	// All Wif file read...check if need to update the Wif Parameter list on disk?
	if(bStatus && (m_bNewWifParameterFound == true))
		DumpParameterIndexTable();

	// Success parsing Wif file
	f.close();
	return bStatus;
}

//////////////////////////////////////////////////////////////////////
// Create STDF file from Wif data parsed
//////////////////////////////////////////////////////////////////////
bool CGWiftoSTDF::WriteStdfFile(QTextStream *hWifFile, const char *strFileNameSTDF)
{
	// now generate the STDF file...
    GS::StdLib::Stdf StdfFile;
    GS::StdLib::StdfRecordReadInfo RecordReadInfo;
    if(StdfFile.Open((char*)strFileNameSTDF,STDF_WRITE) != GS::StdLib::Stdf::NoError)
	{
		// Failed importing CSV file into STDF database
		iLastError = errWriteSTDF;
		
		// Convertion failed.
		return false;
	}

	// Write FAR
	RecordReadInfo.iRecordType = 0;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(1);					// SUN CPU type
	StdfFile.WriteByte(4);					// STDF V4
	StdfFile.WriteRecord();

	if(m_lStartTime <= 0)
		m_lStartTime = QDateTime::currentDateTime().toTime_t();

	// Write MIR
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteDword(m_lStartTime);			// Setup time
	StdfFile.WriteDword(m_lStartTime);			// Start time
	StdfFile.WriteByte(1);						// Station
	StdfFile.WriteByte((BYTE) 'P');				// Test Mode = PRODUCTION
	StdfFile.WriteByte((BYTE) ' ');				// rtst_cod
	StdfFile.WriteByte((BYTE) ' ');				// prot_cod
	StdfFile.WriteWord(65535);					// burn_tim
	StdfFile.WriteByte((BYTE) ' ');				// cmod_cod
	StdfFile.WriteString(m_strLotID.toLatin1().constData());		// Lot ID
	StdfFile.WriteString(m_strProductID.toLatin1().constData());	// Part Type / Product ID
	StdfFile.WriteString(m_strTesterID.toLatin1().constData());		// Node name
	StdfFile.WriteString(m_strTesterType.toLatin1().constData());	// Tester Type
	StdfFile.WriteString(m_strJobName.toLatin1().constData());		// Job name
	StdfFile.WriteString(m_strJobRev.toLatin1().constData());		// Job rev
	StdfFile.WriteString("");					// sublot-id
	StdfFile.WriteString(m_strOperatorID.toLatin1().constData());	// operator
	StdfFile.WriteString("");					// exec-type
	StdfFile.WriteString(m_strSoftRev.toLatin1().constData());		// exe-ver
	StdfFile.WriteString(m_strTestCode.toLatin1().constData());		// test-cod
	StdfFile.WriteString("");					// test-temperature
	// Construct custom Galaxy USER_TXT 
	QString	strUserTxt;
	strUserTxt = GEX_IMPORT_DATAORIGIN_LABEL;	
	strUserTxt += ":";
	strUserTxt += GEX_IMPORT_DATAORIGIN_ATETEST;
	strUserTxt += ":WIF";
	StdfFile.WriteString((char *)strUserTxt.toLatin1().constData());		// user-txt
	StdfFile.WriteString((char *)m_strProgramID.toLatin1().constData());	// aux-file
	StdfFile.WriteString("");							// package-type
	StdfFile.WriteString(m_strProductID.toLatin1().constData());	// familyID
	StdfFile.WriteString("");							// Date-code
	StdfFile.WriteString("");							// Facility-ID
	StdfFile.WriteString("");							// FloorID
	StdfFile.WriteString("");							// ProcessID
	StdfFile.WriteString("");							// OperationFreq
	StdfFile.WriteString(m_strAuxFile.toLatin1().constData());	// Spec-nam
	StdfFile.WriteString("");							// Spec-ver
	StdfFile.WriteString("");							// Flow-id
	StdfFile.WriteString((char *)m_strSetupId.left(255).toLatin1().constData());	// setup_id
	StdfFile.WriteRecord();

	// Write Test results for each line read.
	QString strString;
	QString strSection;
	float	fValue;				// Used for readng floating point numbers.
	int		iIndex;				// Loop index
	int		iXpos=-32768;
	int		iYpos=-32768;
	int		iSBin;
	int		iHBin;
	int		iSite;
	bool	bPassStatus;
	long		iTotalGoodBin,iTotalFailBin;
	long		iTotalTests,iPartNumber;
	QString		strPartId;
	bool		bStatus;
	QStringList	lstSections;
	BYTE		bData;

	bool bWriteWir;
	
	// Reset counters
	bWriteWir = (m_iIndexOffset == 4);
	iTotalGoodBin=iTotalFailBin=0;
	iPartNumber=0;
	iSite = 1;

	//0=PASS, DOE=OK
	//1=FAIL, beam(s) out of range
	//2=FAIL, diffraction efficiency<70%,
	//3=FAIL, Ghosts beams(s) with >1% rel. pwr present
	//4=FAIL, Shift of beams beyond 1% limit
	//5=FAIL, Beam ratio higher than 2

	m_mapWifBinning[0].nNumber = 0;
	m_mapWifBinning[0].strName = "PASS";
	m_mapWifBinning[0].bPass = true;
	m_mapWifBinning[0].nCount = 0;

	m_mapWifBinning[1].nNumber = 1;
	m_mapWifBinning[1].strName = "beam(s) out of range";
	m_mapWifBinning[1].bPass = false;
	m_mapWifBinning[1].nCount = 0;

	m_mapWifBinning[2].nNumber = 2;
	m_mapWifBinning[2].strName = "diffraction efficiency<70%";
	m_mapWifBinning[2].bPass = false;
	m_mapWifBinning[2].nCount = 0;

	m_mapWifBinning[3].nNumber = 3;
	m_mapWifBinning[3].strName = "Ghosts beams(s) with >1% rel. pwr present";
	m_mapWifBinning[3].bPass = false;
	m_mapWifBinning[3].nCount = 0;

	m_mapWifBinning[4].nNumber = 4;
	m_mapWifBinning[4].strName = "Shift of beams beyond 1% limit";
	m_mapWifBinning[4].bPass = false;
	m_mapWifBinning[4].nCount = 0;

	m_mapWifBinning[5].nNumber = 5;
	m_mapWifBinning[5].strName = "Beam ratio higher than 2";
	m_mapWifBinning[5].bPass = false;
	m_mapWifBinning[5].nCount = 0;

	// Write all Parameters read on this wafer.: WIR.PIR,PTR....PTR, PRR, PIR, PTR,PTR...PRR,   ... WRR

	//DOE	X	Y	rej	ZO-1	ZO-2	ZO-3	Uni	BH	g1p	g1x	g1y	g2p	g2x	g2y	g3p	g3x	g3y	g4p	...
	//0	4	0	0	0.30	0.28	0.27	1.57	80.45										...
	//1	5	0	0	0.24	0.22	0.15	1.60	78.40										...
	//2	6	0	0	0.21	0.16	0.12	1.44	83.92										...
	while(hWifFile->atEnd() == false)
	{

		// Read line
		strString = ReadLine(*hWifFile);

		if(strString.isEmpty())
			break;

        lstSections = strString.split("\t", QString::KeepEmptyParts);

		// Check if have the good count
		if(lstSections.count() < m_iIndexOffset)
		{
			bStatus = false;
			iLastError = errInvalidFormatLowInRows;

			StdfFile.Close();
			// Convertion failed.
			return false;
		}

		// Part number
		iPartNumber++;

		strPartId = lstSections[0];

		if(m_iIndexOffset == 4)
		{
			// Extract Column,Row
			iXpos = lstSections[1].toInt();
			iYpos = lstSections[2].toInt();
		}

		// Check if have PassFail info
		if(m_nPassFailIndex > 0)
		{
			iSBin = lstSections[m_nPassFailIndex].toInt(&bStatus);
			if(!bStatus)
				iSBin = (lstSections[m_nPassFailIndex].toLower() == "pass");
		}
		else
			iSBin = 0;

		if(!m_mapWifBinning.contains(iSBin))
		{
			m_mapWifBinning[iSBin].nNumber = iSBin;
			m_mapWifBinning[iSBin].strName = "";
			m_mapWifBinning[iSBin].bPass = (iSBin == 0);
			m_mapWifBinning[iSBin].nCount = 0;
		}
				
		bPassStatus = m_mapWifBinning[iSBin].bPass;
		m_mapWifBinning[iSBin].nCount++;

		iSite = 1;

		if(bWriteWir)
		{
			// Write WIR of new Wafer.
			RecordReadInfo.iRecordType = 2;
			RecordReadInfo.iRecordSubType = 10;
			StdfFile.WriteHeader(&RecordReadInfo);
			StdfFile.WriteByte(1);								// Test head
			StdfFile.WriteByte(255);							// Tester site (all)
			StdfFile.WriteDword(m_lStartTime);					// Start time
			StdfFile.WriteString(m_strWaferID.toLatin1().constData());	// WaferID
			StdfFile.WriteRecord();

			bWriteWir = false;
		}

		// Reset counters
		iTotalTests = 0;

		// Write PIR for parts in this Wafer site
		RecordReadInfo.iRecordType = 5;
		RecordReadInfo.iRecordSubType = 10;
		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteByte(1);					// Test head
		StdfFile.WriteByte(iSite);				// Tester site
		StdfFile.WriteRecord();

		// Read Parameter results for this record
		for(iIndex=m_iIndexOffset;iIndex<m_iTotalParameters;iIndex++)
		{
			if(iIndex >= lstSections.count())
				break;

			strSection = lstSections[iIndex];
			fValue = strSection.toFloat(&bStatus);
			if(bStatus == true)
			{
				// Valid test result...write the PTR
				iTotalTests++;

				RecordReadInfo.iRecordType = 15;
				RecordReadInfo.iRecordSubType = 10;
				StdfFile.WriteHeader(&RecordReadInfo);
				// Compute Test# (add user-defined offset)
				StdfFile.WriteDword(m_pWifParameter[iIndex].nNumber + GEX_TESTNBR_OFFSET_WIF);			// Test Number
				StdfFile.WriteByte(1);				// Test head
				StdfFile.WriteByte(iSite);			// Tester site#
				
				if(!m_pWifParameter[iIndex].bValidLowLimit && !m_pWifParameter[iIndex].bValidHighLimit)
				{
					// No pass/fail information
					bData = 0x40;
				}
				else if(((m_pWifParameter[iIndex].bValidLowLimit==true) && (fValue < m_pWifParameter[iIndex].fLowLimit)) ||
				   ((m_pWifParameter[iIndex].bValidHighLimit==true) && (fValue > m_pWifParameter[iIndex].fHighLimit)))
				{
					bData = 0200;	// Test Failed
				}
				else
				{
					bData = 0;		// Test passed
				}
				StdfFile.WriteByte(bData);							// TEST_FLG
				StdfFile.WriteByte(0x40|0x80);						// PARAM_FLG
				StdfFile.WriteFloat(fValue * GS_POW(10.0,m_pWifParameter[iIndex].nScale));						// Test result
				if(m_pWifParameter[iIndex].bStaticHeaderWritten == false)
				{
					StdfFile.WriteString(m_pWifParameter[iIndex].strName.toLatin1().constData());	// TEST_TXT
					StdfFile.WriteString("");							// ALARM_ID
					bData = 2;	// Valid data.
					if(m_pWifParameter[iIndex].bValidLowLimit==false)
						bData |=0x40;
					if(m_pWifParameter[iIndex].bValidHighLimit==false)
						bData |=0x80;
					StdfFile.WriteByte(bData);							// OPT_FLAG
					StdfFile.WriteByte(-m_pWifParameter[iIndex].nScale);			// RES_SCALE
					StdfFile.WriteByte(-m_pWifParameter[iIndex].nScale);			// LLM_SCALE
					StdfFile.WriteByte(-m_pWifParameter[iIndex].nScale);			// HLM_SCALE
					StdfFile.WriteFloat(m_pWifParameter[iIndex].fLowLimit);		// LOW Limit
					StdfFile.WriteFloat(m_pWifParameter[iIndex].fHighLimit);		// HIGH Limit
					StdfFile.WriteString(m_pWifParameter[iIndex].strUnits.toLatin1().constData());	// Units
					m_pWifParameter[iIndex].bStaticHeaderWritten = true;
				}
				StdfFile.WriteRecord();
			}	// Valid test result
			else
			{
				if(m_pWifParameter[iIndex].bStaticHeaderWritten == false)
				{
					RecordReadInfo.iRecordType = 15;
					RecordReadInfo.iRecordSubType = 10;
					StdfFile.WriteHeader(&RecordReadInfo);
					// Compute Test# (add user-defined offset)
					StdfFile.WriteDword(m_pWifParameter[iIndex].nNumber + GEX_TESTNBR_OFFSET_WIF);			// Test Number
					StdfFile.WriteByte(1);						// Test head
					StdfFile.WriteByte(iSite);					// Tester site#
					
					// No pass/fail information
					bData = 0x52;
					StdfFile.WriteByte(bData);							// TEST_FLG
					StdfFile.WriteByte(0x40|0x80);						// PARAM_FLG
					StdfFile.WriteFloat(0);								// Test result
					StdfFile.WriteString(m_pWifParameter[iIndex].strName.toLatin1().constData());	// TEST_TXT
					StdfFile.WriteString("");							// ALARM_ID
					bData = 2;	// Valid data.
					if(m_pWifParameter[iIndex].bValidLowLimit==false)
						bData |=0x40;
					if(m_pWifParameter[iIndex].bValidHighLimit==false)
						bData |=0x80;
					StdfFile.WriteByte(bData);							// OPT_FLAG
					StdfFile.WriteByte(-m_pWifParameter[iIndex].nScale);			// RES_SCALE
					StdfFile.WriteByte(-m_pWifParameter[iIndex].nScale);			// LLM_SCALE
					StdfFile.WriteByte(-m_pWifParameter[iIndex].nScale);			// HLM_SCALE
					StdfFile.WriteFloat(m_pWifParameter[iIndex].fLowLimit);		// LOW Limit
					StdfFile.WriteFloat(m_pWifParameter[iIndex].fHighLimit);		// HIGH Limit
					StdfFile.WriteString(m_pWifParameter[iIndex].strUnits.toLatin1().constData());	// Units
					m_pWifParameter[iIndex].bStaticHeaderWritten = true;
					StdfFile.WriteRecord();

				}
			}
		}		// Read all results on line

		// Write PRR
		RecordReadInfo.iRecordType = 5;
		RecordReadInfo.iRecordSubType = 20;
		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteByte(1);			// Test head
		StdfFile.WriteByte(iSite);		// Tester site#:1
		if(bPassStatus == true)
		{
			StdfFile.WriteByte(0);				// PART_FLG : PASSED
			iHBin = 0;
			iTotalGoodBin++;
		}
		else
		{
			StdfFile.WriteByte(8);				// PART_FLG : FAILED
			iHBin = 1;
			iTotalFailBin++;
		}
		StdfFile.WriteWord((WORD)iTotalTests);	// NUM_TEST
		StdfFile.WriteWord(iHBin);				// HARD_BIN
		StdfFile.WriteWord(iSBin);				// SOFT_BIN
		StdfFile.WriteWord(iXpos);				// X_COORD
		StdfFile.WriteWord(iYpos);				// Y_COORD
		StdfFile.WriteDword(0);					// No testing time known...
		StdfFile.WriteString(strPartId.toLatin1().constData());		// PART_ID
		StdfFile.WriteString("");			// PART_TXT
		StdfFile.WriteString("");			// PART_FIX
		StdfFile.WriteRecord();
	};			// Read all lines with valid data records in file


	if(m_iIndexOffset == 4)
	{
		// Write WRR for last wafer inserted
		RecordReadInfo.iRecordType = 2;
		RecordReadInfo.iRecordSubType = 20;
		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteByte(1);						// Test head
		StdfFile.WriteByte(255);					// Tester site (all)
		StdfFile.WriteDword(m_lStopTime);			// Time of last part tested
		StdfFile.WriteDword(iTotalGoodBin+iTotalFailBin);	// Parts tested
		StdfFile.WriteDword(0);						// Parts retested
		StdfFile.WriteDword(0);						// Parts Aborted
		StdfFile.WriteDword(iTotalGoodBin);			// Good Parts
		StdfFile.WriteDword((DWORD)-1);				// Functionnal Parts
		StdfFile.WriteString(m_strWaferID.toLatin1().constData());	// WaferID
		StdfFile.WriteString("");					// FabId
		StdfFile.WriteString("");					// FrameId
		StdfFile.WriteString("");					// MaskId
		StdfFile.WriteString(QString("SIDE["+m_strWaferID+"]").toLatin1().constData());	// UserDesc
		StdfFile.WriteRecord();
	}

	QMap<int,CGWifBinning>::Iterator it;

	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 40;

	if(iTotalGoodBin > 0)
	{
		// Write HBR
		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteByte(255);						// Test Head = ALL
		StdfFile.WriteByte(255);						// Test sites = ALL		
		StdfFile.WriteWord(0);							// HBIN
		StdfFile.WriteDword(iTotalGoodBin);			// Total Bins
		StdfFile.WriteByte('P');
		StdfFile.WriteString("PASS");
		StdfFile.WriteRecord();
	}

	if(iTotalFailBin > 0)
	{
		// Write HBR
		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteByte(255);						// Test Head = ALL
		StdfFile.WriteByte(255);						// Test sites = ALL
		StdfFile.WriteWord(1);							// HBIN
		StdfFile.WriteDword(iTotalFailBin);			// Total Bins
		StdfFile.WriteByte('F');
		StdfFile.WriteString("FAIL");
		StdfFile.WriteRecord();
	}

	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 50;
	for(it = m_mapWifBinning.begin(); it != m_mapWifBinning.end(); it++)
	{
		if((*it).nCount == 0)
			continue;

		// Write SBR
		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteByte(255);						// Test Head = ALL
		StdfFile.WriteByte(255);						// Test sites = ALL		
		StdfFile.WriteWord((*it).nNumber);			// HBIN
		StdfFile.WriteDword((*it).nCount);			// Total Bins
		if((*it).bPass)
			StdfFile.WriteByte('P');
		else
			StdfFile.WriteByte('F');
		StdfFile.WriteString( (*it).strName.toLatin1().constData());
		StdfFile.WriteRecord();
	}

	
	// Write MRR
	RecordReadInfo.iRecordType = 1; 
	RecordReadInfo.iRecordSubType = 20;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteDword(m_lStartTime);			// File finish-time.
	StdfFile.WriteRecord();

	// Close STDF file.
	StdfFile.Close();

	// Success
	return true;
}

//////////////////////////////////////////////////////////////////////
// Convert 'FileName' Wif file, to STDF 'strFileNameSTDF' file
//////////////////////////////////////////////////////////////////////
bool CGWiftoSTDF::Convert(const char *WifFileName, const char *strFileNameSTDF)
{
	// No erro (default)
	iLastError = errNoError;

	// If STDF file already exists...do not rebuild it...unless dates not matching!
	QFileInfo fInput(WifFileName);
	QFileInfo fOutput(strFileNameSTDF);

    QFile f( strFileNameSTDF );
    if((f.exists() == true) && (fInput.lastModified() < fOutput.lastModified()))
		return true;

	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	bool bHideProgressAfter=true;
	bool bHideLabelAfter=false;
	if(GexProgressBar != NULL)
	{
		bHideProgressAfter = GexProgressBar->isHidden();
		GexProgressBar->setMaximum(100);
		GexProgressBar->setTextVisible(true);
		GexProgressBar->setValue(0);
		GexProgressBar->show();
	}

	if(GexScriptStatusLabel != NULL)
	{
		if(GexScriptStatusLabel->isHidden())
		{
			bHideLabelAfter = true;
			GS::Gex::Engine::GetInstance().UpdateLabelStatus("Converting data from file "+QFileInfo(WifFileName).fileName()+"...");
			GexScriptStatusLabel->show();
		}
		GS::Gex::Engine::GetInstance().UpdateLabelStatus("Converting data from file "+QFileInfo(WifFileName).fileName()+"...");
		GexScriptStatusLabel->show();
	}
    QCoreApplication::processEvents();

    if(ReadWifFile(WifFileName,strFileNameSTDF) != true)
	{
		//////////////////////////////////////////////////////////////////////
		// For ProgressBar
		if((GexProgressBar != NULL)
		&& bHideProgressAfter)
			GexProgressBar->hide();
		
		if((GexScriptStatusLabel != NULL)
		&& bHideLabelAfter)
			GexScriptStatusLabel->hide();
		return false;	// Error reading Wif file
	}
	
	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	if((GexProgressBar != NULL)
	&& bHideProgressAfter)
		GexProgressBar->hide();
	
	if((GexScriptStatusLabel != NULL)
	&& bHideLabelAfter)
		GexScriptStatusLabel->hide();
	
	// Convertion successful
	return true;
}

//////////////////////////////////////////////////////////////////////
// Normalize test limits when writing into PTR.
//////////////////////////////////////////////////////////////////////
void CGWiftoSTDF::NormalizeValues(QString &strUnits,float &fValue, int &nScale, bool &bIsNumber)
{
	int i;
	QString strValue = strUnits;

	// In strValue, the current value with unit
	bIsNumber = false;
	i = strValue.length();
	while(i > 0)
	{
		strValue.mid(i-1,1).toInt(&bIsNumber);
		if(bIsNumber)
			break;
		i--;
	}

	if(strValue.length() <= i)
	{
		// no unit
		strUnits = "";
	}
	else
	{
		strUnits = strValue.right(strValue.length()-i);
		strValue = strValue.left(i);
		if(strUnits == "NONE")
			strUnits = "";
	}

	fValue = strValue.toFloat(&bIsNumber);
	nScale=0;

	if(strUnits.length() <= 1)
	{
		// units too short to include a prefix, then keep it 'as-is'
		return;
	}

	QChar cPrefix = strUnits[0];
	switch(cPrefix.toLatin1())
	{
		case 'm': // Milli
			nScale = -3;
			break;
		case 'u': // Micro
			nScale = -6;
			break;
		case 'n': // Nano
			nScale = -9;
			break;
		case 'p': // Pico
			nScale = -12;
			break;
		case 'f': // Fento
			nScale = -15;
			break;
		case 'K': // Kilo
			nScale = 3;
			break;
		case 'M': // Mega
			nScale = 6;
			break;
		case 'G': // Giga
			nScale = 9;
			break;
		case 'T': // Tera
			nScale = 12;
			break;
	}
	if(nScale != 0)
	{
		fValue *= GS_POW(10.0,nScale);
		strUnits = strUnits.mid(1);	// Take all characters after the prefix.
	}
}

//////////////////////////////////////////////////////////////////////
// Read line : skip empty line
//////////////////////////////////////////////////////////////////////
QString CGWiftoSTDF::ReadLine(QTextStream& hFile)
{
	QString strString;
	
	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	if(GexProgressBar != NULL)
	{
        while((int) hFile.device()->pos() > iNextFilePos)
		{
			iProgressStep += 100/iFileSize + 1;
			iNextFilePos  += iFileSize/100 + 1;
			GexProgressBar->setValue(iProgressStep);
		}
	}
    QCoreApplication::processEvents();
			
	do
		strString = hFile.readLine();
	while(!strString.isNull() && strString.isEmpty());

	return strString;

}
