//////////////////////////////////////////////////////////////////////
// import_TestStand.cpp: Convert a .TXT (NI: National Instrument Test Stand) file to STDF V4.0
//////////////////////////////////////////////////////////////////////

#ifdef _WIN32
#include "windows.h"		// For 'GetWindowsDirectoryA' declaration
#endif

#include <qfileinfo.h>
#include <qprogressbar.h>
#include <qapplication.h>
#include <qlabel.h>

#include "engine.h"
#include "import_teststand.h"
#include "import_constants.h"

// in main.cpp
extern QLabel			*GexScriptStatusLabel;	// Handle to script status text in status bar
extern QProgressBar	*	GexProgressBar;		// Handle to progress bar in status bar

//////////////////////////////////////////////////////////////////////
// Construction
//////////////////////////////////////////////////////////////////////
CGNItoSTDF::CGNItoSTDF()
{
	// Default: TXT parameter list on disk includes all known CSV/TXT parameters...
	bNewCsvParameterFound = false;
	m_iTotalUnits = 0;
	m_iTotalGoodBin = 0;			// Total good parts (used to create summary record)
	m_iTotalFailBin = 0;			// Total bad parts (used to create summary record)

}

//////////////////////////////////////////////////////////////////////
// Destruction
//////////////////////////////////////////////////////////////////////
CGNItoSTDF::~CGNItoSTDF()
{
	m_lUnitTestDate = -1;
}

//////////////////////////////////////////////////////////////////////
// Test result structure: Constructor
//////////////////////////////////////////////////////////////////////
CGNiParameter::CGNiParameter()
{
	clear();
}

//////////////////////////////////////////////////////////////////////
// Test result structure: clear members
//////////////////////////////////////////////////////////////////////
void	CGNiParameter::clear(void)
{
	strName="";	// Parameter name. E.g: "Idd_Total_Shutdown"
	strUnits="";	// Parameter units,E.g: "A"
	bValidLowLimit = false;	// 'true' if Low limit defined
	bValidHighLimit= false;	// 'true' if High limit defined
	bValidResult = false;	// 'true' if a valild test result is available
	bPassed = true;
	lfTestTime = -1;	// Execution time for the test. A negative value means 'not available'
}

//////////////////////////////////////////////////////////////////////
// Get Error
//////////////////////////////////////////////////////////////////////
QString CGNItoSTDF::GetLastError()
{
	strLastError = "Import NI-TestStand: ";

	switch(iLastError)
	{
		default:
		case errNoError:
			strLastError += "No Error";
			break;
		case errOpenFail:
			strLastError += "Failed to open file";
			break;
		case errInvalidFormatParameter:
			strLastError += "Invalid file format: Didn't find 'Parameter' line";
			break;
		case errWriteSTDF:
			strLastError += "Failed creating temporary file. Folder permission issue?";
			break;	
		case errLicenceExpired:
			strLastError += "License has expired or Data file out of date...";
			break;	
	}
	// Return Error Message
	return strLastError;
}


//////////////////////////////////////////////////////////////////////
// Load CSV Parameter table from DISK
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::LoadParameterIndexTable(void)
{
	QString	strCsvTableFile;
	QString	strString;

    strCsvTableFile  = GS::Gex::Engine::GetInstance().Get("UserFolder").toString();
	strCsvTableFile += GEX_CSV_PARAMETERS;

	// Open CSV Parameter table file
    QFile f( strCsvTableFile );
    if(!f.open( QIODevice::ReadOnly ))
		return;

	// Assign file I/O stream
	QTextStream hCsvTableFile(&f);

	// Skip comment lines
	do
	{
	  strString = hCsvTableFile.readLine();
	}
    while((strString.indexOf("----------------------") < 0) && (hCsvTableFile.atEnd() == false));

	// Read lines
	pFullCsvParametersList.clear();
	strString = hCsvTableFile.readLine();
	while (strString.isNull() == false)
	{
		// Save Parameter name in list
		pFullCsvParametersList.append(strString);
		// Read next line
		strString = hCsvTableFile.readLine();
	};

	// Close file
	f.close();
}

//////////////////////////////////////////////////////////////////////
// Save CSV Parameter table to DISK
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::DumpParameterIndexTable(void)
{
	QString		strCsvTableFile;
	QString		strString;

    strCsvTableFile  = GS::Gex::Engine::GetInstance().Get("UserFolder").toString();
	strCsvTableFile += GEX_CSV_PARAMETERS;

	// Open CSV Parameter table file
    QFile f( strCsvTableFile );
    if(!f.open( QIODevice::WriteOnly ))
		return;

	// Assign file I/O stream
	QTextStream hCsvTableFile(&f);

	// First few lines are comments:
	hCsvTableFile << "############################################################" << endl;
	hCsvTableFile << "# DO NOT EDIT THIS FILE!" << endl;
    hCsvTableFile << "# Quantix Examinator: CSV Parameters detected" << endl;
	hCsvTableFile << "# www.mentor.com" << endl;
    hCsvTableFile << "# Quantix Examinator reads and writes into this file..." << endl;
	hCsvTableFile << "-----------------------------------------------------------" << endl;

	// Write lines
	// pFullCsvParametersList.sort();
	for(int nIndex = 0; nIndex < pFullCsvParametersList.count(); nIndex++)
	{
		// Write line
		hCsvTableFile << pFullCsvParametersList[nIndex] << endl;
	};

	// Close file
	f.close();
}

//////////////////////////////////////////////////////////////////////
// If Examinator doesn't have this CSV parameter in his dictionnary, have it added.
// return: Parameter index (offset) in array.
//////////////////////////////////////////////////////////////////////
int CGNItoSTDF::UpdateParameterIndexTable(const QString &strParamName)
{
	// Check if the table is empty...if so, load it from disk first!
	if(pFullCsvParametersList.isEmpty() == true)
	{
		// Load CSV parameter table from disk...
		LoadParameterIndexTable();
	}
	
	// Check if Parameter name already in table...if not, add it to the list
	// the new full list will be dumped to the disk at the end.
    int iTestID = pFullCsvParametersList.indexOf(strParamName);
	if(iTestID < 0)
	{
		// Update list
		pFullCsvParametersList.append(strParamName);

		// Set flag to force the current CSV table to be updated on disk
		bNewCsvParameterFound = true;

		// Index is current object position in array (last item)!
		iTestID = pFullCsvParametersList.count()-1;
	}

	// Return Test index
	return iTestID;
}

//////////////////////////////////////////////////////////////////////
// Extract date from string (eg: Wednesday, February 16, 2005)
//////////////////////////////////////////////////////////////////////
QDate CGNItoSTDF::extractDate(const QString &strDate)
{
	QDate	cDate;
	char	szMonth[16];
	int		iDay,iMonth,iYear;

	sscanf(strDate.toLatin1().constData(),"%*s %15s %d %*c %d",szMonth, &iDay, &iYear);
	
	QString strMonth = QString(szMonth).toLower();
	
	if(strMonth == "january")
		iMonth = 1;
	else
	if(strMonth == "february")
		iMonth = 2;
	else
	if(strMonth == "march")
		iMonth = 3;
	else
	if(strMonth == "april")
		iMonth = 4;
	else
	if(strMonth == "may")
		iMonth = 5;
	else
	if(strMonth == "june")
		iMonth = 6;
	else
	if(strMonth == "july")
		iMonth = 7;
	else
	if(strMonth == "august")
		iMonth = 8;
	else
	if(strMonth == "september")
		iMonth = 9;
	else
	if(strMonth == "october")
		iMonth = 10;
	else
	if(strMonth == "november")
		iMonth = 11;
	else
		iMonth = 12;

    if (iYear < 99) iYear += 1900;
    cDate.setDate(iYear,iMonth,iDay);
	return cDate;
}

//////////////////////////////////////////////////////////////////////
// Extract Time from string (eg: 11:58:13 AM)
//////////////////////////////////////////////////////////////////////
QTime CGNItoSTDF::extractTime(const QString &strTime)
{
	QTime cTime;

	char	szAmPm[5];
	int		iHour,iMin,iSec;

	sscanf(strTime.toLatin1().constData(),"%d %*c %d %*c %d %3s",&iHour,&iMin,&iSec,szAmPm);

	QString strAmPm = QString(szAmPm).toLower();

	if(strAmPm == "pm")
		iHour += 12;	// Time is PM, so add 12 hours

	cTime.setHMS(iHour,iMin,iSec);
	return cTime;
}

//////////////////////////////////////////////////////////////////////
// Read and Parse the NI (NAtional Instruments) TestStand file
//////////////////////////////////////////////////////////////////////
bool CGNItoSTDF::ReadNiFile(const char *strNiFileName,const char *strFileNameSTDF)
{
	// Open NI file
    QFile f( strNiFileName );
    if(!f.open( QIODevice::ReadOnly ))
	{
		// Failed Opening NI file
		iLastError = errOpenFail;
		
		// Convertion failed.
		return false;
	}
	// Assign file I/O stream
	QTextStream hNiFile(&f);

	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	iProgressStep = 0;
	iNextFilePos = 0;
	iFileSize = f.size() + 1;
    QCoreApplication::processEvents();
	
	// Current time (in case Header doesn't include a date/time line)
	m_lUnitTestDate = time(NULL);
	strTesterName = "National Instruments";
	strTesterType = strProgramName= strTesterName;
	strOperator = strTesterName;
	iBurninTime = 65535;

	// Loop reading file until end is reached & generate STDF file dynamically.
    bool bStatus = WriteStdfFile(&hNiFile,strFileNameSTDF);
	if(!bStatus)
		QFile::remove(strFileNameSTDF);

	// Close NI file
	f.close();

	// All NI file read...check if need to update the CSV/TXT Parameter list on disk?
	if(bNewCsvParameterFound == true)
		DumpParameterIndexTable();

	// Success parsing NI file
	return bStatus;
}

//////////////////////////////////////////////////////////////////////
// Write STDF.DTR record with all run header functions (operator name, time, etc...)
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WriteRunHeader(void)
{
	QString strString;

	// Station ID
	if(!strTesterName.isEmpty())
	{
		strString = "Station ID: " + strTesterName;
		WriteDTR(strString);
	}

	// Serial number
	if(!strPartID.isEmpty())
	{
		strString = "Serial Number: " + strPartID;
		WriteDTR(strString);
	}

	// Date & Time
	strString = "Date: " + m_cDateTime.toString("dddd, MMMM d, yyyy  - h:m:s AP");
	WriteDTR(strString);

	// Operator
	if(!strOperator.isEmpty())
	{
		strString = "Operator: " + strOperator;
		WriteDTR(strString);
	}

	// Execution time
	strString = "Execution Time: " + QString::number(m_lfExecTime);
	strString += " seconds";
	WriteDTR(strString);

	// Number of results
	if(!strOperator.isEmpty())
	{
		strString = "Number of Results: " + QString::number(m_iTotalTests);
		WriteDTR(strString);
	}

	// Small separator
	WriteDTR(".");
}

//////////////////////////////////////////////////////////////////////
// Write STDF.MIR record
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WriteMIR(void)
{
	if(m_lUnitTestDate <= 0)
		m_lUnitTestDate = QDateTime::currentDateTime().toTime_t();

	// Write MIR
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteDword(m_lUnitTestDate);			// Setup time
	StdfFile.WriteDword(m_lUnitTestDate);			// Start time
	StdfFile.WriteByte(1);						// Station
	StdfFile.WriteByte((BYTE) 'P');				// Test Mode = PRODUCTION
	StdfFile.WriteByte((BYTE) ' ');				// rtst_cod
	StdfFile.WriteByte((BYTE) ' ');				// prot_cod
	StdfFile.WriteWord(iBurninTime);			// burn_tim
	StdfFile.WriteByte((BYTE) ' ');				// cmod_cod
	StdfFile.WriteString(strLotID.toLatin1().constData());		// Lot ID
	StdfFile.WriteString(strProductID.toLatin1().constData());	// Part Type / Product ID
	StdfFile.WriteString(strTesterName.toLatin1().constData());	// Node name
	StdfFile.WriteString(strTesterType.toLatin1().constData());	// Tester Type
	StdfFile.WriteString(strProgramName.toLatin1().constData());	// Job name
	StdfFile.WriteString(strProgramRev.toLatin1().constData());	// Job rev
	StdfFile.WriteString(strSubLotID.toLatin1().constData());	// sublot-id
	StdfFile.WriteString(strOperator.toLatin1().constData());	// operator
	StdfFile.WriteString(strExecType.toLatin1().constData());	// exec-type
	StdfFile.WriteString(strExecRev.toLatin1().constData());		// exe-ver
	StdfFile.WriteString(strTestCode.toLatin1().constData());	// test-cod
	StdfFile.WriteString(strTemperature.toLatin1().constData());	// test-temperature

	// Construct custom Galaxy USER_TXT
	QString	strUserTxt;
	strUserTxt = GEX_IMPORT_DATAORIGIN_LABEL;	
	strUserTxt += ":";
	strUserTxt += GEX_IMPORT_DATAORIGIN_ATETEST;
	strUserTxt += ":National Instruments";
	StdfFile.WriteString(strUserTxt.toLatin1().constData());			// user-txt
	StdfFile.WriteString("");									// aux-file
	StdfFile.WriteString(strPackageType.toLatin1().constData());		// package-type
	StdfFile.WriteString(strFamilyID.toLatin1().constData());		// familyID
	StdfFile.WriteString("");									// Date-code
	StdfFile.WriteString(strFacilityID.toLatin1().constData());		// Facility-ID
	StdfFile.WriteString(strFloorID.toLatin1().constData());			// FloorID
	StdfFile.WriteString(strProcessID.toLatin1().constData());		// ProcessID
	StdfFile.WriteString(strFrequencyStep.toLatin1().constData());	// Frequency/Step
	StdfFile.WriteRecord();
}

//////////////////////////////////////////////////////////////////////
// Write STDF.DTR
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WriteDTR(const QString &strString,const QString &strColor/*=NULL*/)
{
	// Write DTR
	RecordReadInfo.iRecordType = 50; 
	RecordReadInfo.iRecordSubType = 30;
	StdfFile.WriteHeader(&RecordReadInfo);

	// Check if color specified (used when printing datalog in HTML mode!)
	QString strText;
	if(!strColor.isNull())
	{
		// Specify RGB HTML color code (eg: #008000)
		strText = "<font_cmd> " + strColor;
		strText += " ";
		strText += strString;
	} 
	else
		strText = strString;

	StdfFile.WriteString(strText.toLatin1().constData());	// Comment line
	StdfFile.WriteRecord();
}

//////////////////////////////////////////////////////////////////////
// Write STDF.PIR 
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WritePIR(void)
{
	// Write PIR
	RecordReadInfo.iRecordType = 5;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(1);		// Test head
	StdfFile.WriteByte(1);		// Tester site#
	StdfFile.WriteRecord();	
}

//////////////////////////////////////////////////////////////////////
// Write STDF.PTR for current test result
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WritePTR(void)
{
	QString strTestName;
	int iTestNumber;
	BYTE	bData;

	// If first test result in flow, write PIR
	if(m_iTotalSamplesTests == 0)
		WritePIR();

	// Set record type (PTR)
	RecordReadInfo.iRecordType = 15;
	RecordReadInfo.iRecordSubType = 10;

	if(m_NiParameter.bValidResult)
	{
		// Write test result entry.
		strTestName = m_NiParameter.strName + ": Measurements";

		// Get Test# assigned to this test (create entry if it doesn't exist).
		iTestNumber = UpdateParameterIndexTable(strTestName) + GEX_TESTNBR_OFFSET_CSV;

		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteDword(iTestNumber);	// Test Number
		StdfFile.WriteByte(1);				// Test head
		StdfFile.WriteByte(1);				// Tester site#

		if(m_NiParameter.bPassed)
			bData = 0;		// Test passed
		else
			bData = 0200;	// Test Failed
		StdfFile.WriteByte(bData);								// TEST_FLG
		StdfFile.WriteByte(0x40|0x80);							// PARAM_FLG
		StdfFile.WriteFloat(m_NiParameter.fValue);				// Test result
		StdfFile.WriteString(strTestName.toLatin1().constData());	// TEST_TXT
		StdfFile.WriteString("");								// ALARM_ID
		bData = 2;	// Valid data.
		if(m_NiParameter.bValidLowLimit==false)
			bData |=0x40;
		if(m_NiParameter.bValidHighLimit==false)
			bData |=0x80;
		StdfFile.WriteByte(bData);							// OPT_FLAG
		StdfFile.WriteByte(0);								// RES_SCALE
		StdfFile.WriteByte(0);								// LLM_SCALE
		StdfFile.WriteByte(0);								// HLM_SCALE
		StdfFile.WriteFloat(m_NiParameter.fLowLimit);		// LOW Limit
		StdfFile.WriteFloat(m_NiParameter.fHighLimit);		// HIGH Limit
		if(!m_NiParameter.strUnits.isEmpty())
			StdfFile.WriteString(m_NiParameter.strUnits.toLatin1().constData());	// Units
		StdfFile.WriteRecord();

		// Count number of parameters datalogged!
		m_iTotalSamplesTests++;
	}

	// If Execution time is available, create a Test entry for it.
	if(m_NiParameter.lfTestTime >= 0)
	{

		strTestName = m_NiParameter.strName + ": Module Time";

		// Get Test# assigned to this test (create entry if it doesn't exist).
		int iTestNumber = UpdateParameterIndexTable(strTestName) + GEX_TESTNBR_OFFSET_CSV;

		StdfFile.WriteHeader(&RecordReadInfo);
		StdfFile.WriteDword(iTestNumber);	// Test Number
		StdfFile.WriteByte(1);				// Test head
		StdfFile.WriteByte(1);				// Tester site#

		if(m_NiParameter.bPassed)
			bData = 0;		// Test passed
		else
			bData = 0200;	// Test Failed
		StdfFile.WriteByte(bData);								// TEST_FLG
		StdfFile.WriteByte(0x40|0x80);							// PARAM_FLG
		StdfFile.WriteFloat(m_NiParameter.lfTestTime);			// Test result
		StdfFile.WriteString(strTestName.toLatin1().constData());	// TEST_TXT
		StdfFile.WriteString("");								// ALARM_ID
		StdfFile.WriteByte(0xC2);								// OPT_FLAG: Valid data, no test limits
		StdfFile.WriteByte(0);									// RES_SCALE
		StdfFile.WriteByte(0);									// LLM_SCALE
		StdfFile.WriteByte(0);									// HLM_SCALE
		StdfFile.WriteFloat(0.0f);		// LOW Limit: field to be ignored
		StdfFile.WriteFloat(0.0f);		// HIGH Limit: field to be ignored
		StdfFile.WriteString("sec.");	// Units: seconds
		StdfFile.WriteRecord();

		// Count number of parameters datalogged!
		m_iTotalSamplesTests++;
	}

	// Clear parameter flags
	m_NiParameter.clear();
}


//////////////////////////////////////////////////////////////////////
// Write STDF.PRR record
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WritePRR(void)
{
	// Write PRR
	int		wSoftBin, wHardBin;
	long	ldExecTime;

	// If no samples in flow, still need to write a PIR!
	if(m_iTotalSamplesTests == 0)
		WritePIR();

	RecordReadInfo.iRecordType = 5;
	RecordReadInfo.iRecordSubType = 20;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(1);			// Test head
	// Tester site#
	StdfFile.WriteByte(1);	// Tester site#: always forced to 1.
	if(m_bPassFail == true)
	{
		StdfFile.WriteByte(0);				// PART_FLG : PASSED
		wSoftBin = wHardBin = 1;
		m_iTotalGoodBin++;
	}
	else
	{
		StdfFile.WriteByte(8);				// PART_FLG : FAILED
		wSoftBin = wHardBin = 0;
		m_iTotalFailBin++;
	}

	StdfFile.WriteWord((WORD)m_iTotalSamplesTests);	// NUM_TEST
	StdfFile.WriteWord(wHardBin);           // HARD_BIN
	StdfFile.WriteWord(wSoftBin);           // SOFT_BIN
	StdfFile.WriteWord((WORD)-32768);		// X_COORD
	StdfFile.WriteWord((WORD)-32768);		// Y_COORD

	if(m_lfExecTime > 0)
		ldExecTime = (long) (m_lfExecTime*1000.0f);
	else
		ldExecTime = 0;
	StdfFile.WriteDword(ldExecTime);					// Testing time (if known, otherwise: 0)
	StdfFile.WriteString(strPartID.toLatin1().constData());	// PART_ID
	StdfFile.WriteRecord();	
}

//////////////////////////////////////////////////////////////////////
// Write STDF.SBR and STDF.HBR records
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WriteSBR_HBR(void)
{
	// Write SBR Bin0 (FAIL)
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 50;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);					// Test Head = ALL
	StdfFile.WriteByte(255);					// Test sites = ALL		
	StdfFile.WriteWord(0);						// SBIN = 0
	StdfFile.WriteDword(m_iTotalFailBin);		// Total Bins
	StdfFile.WriteByte('F');					// Bin type: Pass / Fail
	StdfFile.WriteString("Total Bad Units");		// Bin name
	StdfFile.WriteRecord();

	// Write SBR Bin1 (PASS)
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 50;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);					// Test Head = ALL
	StdfFile.WriteByte(255);					// Test sites = ALL		
	StdfFile.WriteWord(1);						// SBIN = 1
	StdfFile.WriteDword(m_iTotalGoodBin);		// Total Bins
	StdfFile.WriteByte('P');					// Bin type: Pass / Fail
	StdfFile.WriteString("Total Good Units");		// Bin name
	StdfFile.WriteRecord();

	// Write HBR Bin0 (FAIL)
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 40;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);					// Test Head = ALL
	StdfFile.WriteByte(255);					// Test sites = ALL		
	StdfFile.WriteWord(0);						// HBIN = 0
	StdfFile.WriteDword(m_iTotalFailBin);		// Total Bins
	StdfFile.WriteByte('F');					// Bin type: Pass / Fail
	StdfFile.WriteString("Total Bad Units");		// Bin name
	StdfFile.WriteRecord();

	// Write HBR Bin1 (PASS)
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 40;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);					// Test Head = ALL
	StdfFile.WriteByte(255);					// Test sites = ALL		
	StdfFile.WriteWord(1);						// HBIN = 1
	StdfFile.WriteDword(m_iTotalGoodBin);		// Total Bins
	StdfFile.WriteByte('P');					// Bin type: Pass / Fail
	StdfFile.WriteString("Total Good Units");		// Bin name
	StdfFile.WriteRecord();
}


//////////////////////////////////////////////////////////////////////
// Write STDF.PCR
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WritePCR(void)
{
	// Write PCR
	RecordReadInfo.iRecordType = 1; 
	RecordReadInfo.iRecordSubType = 30;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);					// Test Head = ALL
	StdfFile.WriteByte(255);					// Test sites = ALL	
	long iTotalParts = m_iTotalGoodBin + m_iTotalFailBin;
	StdfFile.WriteDword(iTotalParts);			// Total Parts tested
	StdfFile.WriteDword(0);						// Total Parts re-tested
	StdfFile.WriteDword(0);						// Total Parts aborted
	StdfFile.WriteDword(m_iTotalGoodBin);			// Total GOOD Parts
	StdfFile.WriteRecord();
}

//////////////////////////////////////////////////////////////////////
// Write STDF.MRR
//////////////////////////////////////////////////////////////////////
void CGNItoSTDF::WriteMRR(void)
{
	// Write MRR
	RecordReadInfo.iRecordType = 1; 
	RecordReadInfo.iRecordSubType = 20;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteDword(m_lUnitTestDate + (long) m_lfExecTime);			// Time of last device start-time + its testing time.
	StdfFile.WriteRecord();
}

//////////////////////////////////////////////////////////////////////
// Check if File is compatible with NI format
//////////////////////////////////////////////////////////////////////
bool CGNItoSTDF::IsCompatible(const char *szFileName)
{
	QString strString;
	QString strSection;
	QString strValue;
	QString	strSite;

	// Open hCsmFile file
    QFile f( szFileName );
    if(!f.open( QIODevice::ReadOnly ))
	{
		// Failed Opening ASL1000 file
		return false;
	}
	// Assign file I/O stream
	QTextStream hNiFile(&f);

	//////////////////////////////////////////////////////////////////////
	// First, find the header first two lines:
	// *****************
	// UUT Report
	bool bValidSection = false;
	do
		strString = hNiFile.readLine();
	while(!strString.isNull() && strString.isEmpty());

	if(strString.startsWith("**********************"))
	{
		// First line is okay, then check if next line is okay too!
		do
			strString = hNiFile.readLine();
		while(!strString.isNull() && strString.isEmpty());
		if(strString == "UUT Report")
			bValidSection = true;
			// Yes, this is really a NI TestStand data file!
	}

	if(!bValidSection)
	{
		// Incorrect header...this is not a valid NI file!
		// Close file
		f.close();
		return false;
	}

	f.close();

	return true;
}

//////////////////////////////////////////////////////////////////////
// Create STDF file from CSV data parsed
//////////////////////////////////////////////////////////////////////
bool CGNItoSTDF::WriteStdfFile(QTextStream *hNiFile, const char *strFileNameSTDF)
{
	// Read NI file and generate the STDF file in parallel
    if(StdfFile.Open((char*)strFileNameSTDF,STDF_WRITE) != GS::StdLib::Stdf::NoError)
	{
		// Failed importing CSV file into STDF database
		iLastError = errWriteSTDF;
		
		// Convertion failed.
		return false;
	}

	// Write STDF.FAR
	RecordReadInfo.iRecordType = 0;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(1);					// SUN CPU type
	StdfFile.WriteByte(4);					// STDF V4
	StdfFile.WriteRecord();


	bool	bValidSection;
	bool	bTestResult;
	QChar	cChar;
	QString strString;
	QString strKeyword;			// Holds a keyword of the string to parse
	QString	strKeywordLower;	// Holds the keyword string after conversion to lowercase
	QString strSection;			// Holds a section of the string to parse
	QString	strSectionLower;	// Holds the string after conversion to lowercase

	// Label where we loop until end of file met.
parse_file:

	//////////////////////////////////////////////////////////////////////
	// First, find the header first two lines:
	// *****************
	// UUT Report
	bValidSection = false;
	do
	{
		strString = ReadLine(*hNiFile);
		if(strString.startsWith("**********************"))
		{
			// First line is okay, then check if next line is okay too!
			strString = ReadLine(*hNiFile);
			if(strString == "UUT Report")
				bValidSection = true;			{
				break;	// Yes, this is really a NI TestStand data file!
			}
		}
	}
	while(hNiFile->atEnd() == false);

	if(!bValidSection)
	{
		// End of file...this is fine if we have already some data parsed, otherwise it's an error!
		if(m_iTotalUnits)
			goto close_file;	// We've some results dataloged, therefore we can exit from the loop now and close the STDF file!

		// Incorrect header...this is not a valid NI file!
		iLastError = errInvalidHeader;
		
		// Convertion failed.
		return false;
	}

	//////////////////////////////////////////////////////////////////////
	// Secound: parse the header
	bValidSection = false;
	do
	{
		strString = ReadLine(*hNiFile);
		strSection = strString.section(':',0,0);	// First field is 'Parameter'
		strSection = strSection.trimmed();	// remove leading spaces.
		strSection = strSection.toLower();

		if(strSection == "station id")
		{
			strTesterName = strString.section(':',1);
			strTesterName = strTesterName.trimmed();
		}
		else
		if(strSection == "serial number")
		{
			strPartID = strString.section(':',1);
			strPartID = strPartID.trimmed();
		}
		else
		if(strSection == "date")
		{
			// eg: Wednesday, February 16, 2005
			strSection = strString.section(':',1);
			m_cDate = extractDate(strSection);
		}
		else
		if(strSection == "time")
		{
			// eg: 11:58:13 AM
			strSection = strString.section(':',1);
			m_cTime = extractTime(strSection);
		}
		else
		if(strSection == "operator")
		{
			strOperator = strString.section(':',1);
			strOperator = strOperator.trimmed();
		}
		else
		if(strSection == "execution time")
		{
			strSection = strString.section(':',1);
			m_lfExecTime = 0;
			sscanf(strSection.toLatin1().constData(),"%f", &m_lfExecTime);	// Execution time in seconds
		}
		else
		if(strSection == "number of results")
		{
			strSection = strString.section(':',1);
			sscanf(strSection.toLatin1().constData(),"%ld", &m_iTotalTests);	// Total tests executed in the sequence
		}
		else
		if(strSection == "uut result")
		{
			strSection = strString.section(':',1);
			strSection = strSection.trimmed();
			strSectionLower = strSection.toLower();
			if(strSectionLower == "failed")
				m_bPassFail = false;
			else
				m_bPassFail = true;
		}
		else
		if((strSection == "begin sequence") || (strSection == "end uut report"))
		{
			bValidSection = true;

			// Write the run header (operator, date, etc...)
			WriteRunHeader();

			break;	// found first line of the Unit results to process...or end of file!
		}
	}
	while(hNiFile->atEnd() == false);

	if(!bValidSection)
	{
		// Incorrect header...this is not a valid NI file!
		iLastError = errInvalidHeader;
		
		// Convertion failed.
		return false;
	}

	// Line just after 'begin sequence' is normally the test flow file. eg: (C:\Program Files\National Instruments\TestStand 3.1\Examples\Demo\C\auto.seq)
	// or: '(Unsaved Sequence File)'
	strProgramName = ReadLine(*hNiFile);

	// Write the DTR showing the begin sequence & file name.
	WriteDTR(strString);		// 'Begin Sequence: xxxx'
	WriteDTR(strProgramName);	// '(c:\\sdksdnkdsxxxx.seq'
	// Small separator
	WriteDTR(".");


	// Write STDF MIR record if this is the first time we process the header.
	if(m_iTotalUnits == 0)
		WriteMIR();

	//////////////////////////////////////////////////////////////////////
	// Read the test results (if any)
	m_iTotalSamplesTests = 0;	// Reset count of tests dataloged in test sequence.
	bTestResult = false;
	bValidSection = false;

	while(hNiFile->atEnd() == false)
	{
next_line:
		// Skip all empty lines
		strString = ReadLine(*hNiFile);

		// Extract keyword before the ':' character
		strSection = strString.section(':',0,0);
		if(strSection.isEmpty())
		{
			// this line has no ':', so it is pure datalog comment!
			WriteDTR(strString,"#008000");
			goto next_line;
		}

		// Check if end of tests dataloged in test sequence
		if(strSection == "End UUT Report")
		{
			bValidSection = true;
			break;
		}

		//  See what type of line we have...
		strKeyword = strSection.trimmed();
		strKeywordLower = strKeyword.toLower();

		if(strKeywordLower == "begin sequence")
		{
			// If a previous test has to be saved to STDF file, then do it!
			if(bTestResult)
				WritePTR();
			bTestResult = false;

			// Line just after 'begin sequence' is normally the test flow file. eg: (C:\Program Files\National Instruments\TestStand 3.1\Examples\Demo\C\auto.seq)
			// or: '(Unsaved Sequence File)'
			strProgramName = ReadLine(*hNiFile);

			// Write the DTR showing the begin sequence & file name.
			WriteDTR(strString);		// 'Begin Sequence: xxxx'
			WriteDTR(strProgramName);	// '(c:\\sdksdnkdsxxxx.seq'
			// Small separator
			WriteDTR(".");
		}
		else
		if(strKeywordLower == "end sequence")
		{
			// If a previous test has to be saved to STDF file, then do it!
			if(bTestResult)
				WritePTR();
			bTestResult = false;

			// End of test flow sequence: write event to DTR record.
			WriteDTR(strString);
		}
		else
		if(strKeywordLower == "pass/fail")
		{
			// Pass / Fail flag for this test
			strSection = strString.section(':',1,1);
			strSection = strSection.trimmed();	// remove leading spaces.
			strSectionLower = strSection.toLower();

			// functional test mapped to parametric result!
			m_NiParameter.bValidResult = true;

			if(strSectionLower == "true")
			{
				m_NiParameter.fValue = 1;	// Test is PASS (1)
				m_NiParameter.bPassed = true;
			}
			else
			{
				m_NiParameter.fValue = 0;	// Test is FAIL (0)
				m_NiParameter.bPassed = false;
			}
		}
		else
		if(strKeywordLower == "measurement")
		{
			// Test result
			strSection = strString.section(':',1,1);
			m_NiParameter.fValue = strSection.toFloat();
			m_NiParameter.bValidResult = true;
		}
		else
		if(strKeywordLower == "units")
		{
			// Test units
			strSection = strString.section(':',1,1);
			m_NiParameter.strUnits = strSection.trimmed();	// remove leading spaces.
		}
		else
		if(strKeywordLower == "module time")
		{
			// Pass / Fail flag for this test
			strSection = strString.section(':',1,1);
			m_NiParameter.lfTestTime = strSection.toFloat();
		}
		else
		if(strKeywordLower == "limits")
		{
			// Do nothing as limits are detailed in the following lines!
		}
		else
		if(strKeywordLower == "low")
		{
			// Test low limit
			strSection = strString.section(':',1,1);
			m_NiParameter.fLowLimit = strSection.toFloat();
			m_NiParameter.bValidLowLimit = true;
		}
		else
		if(strKeywordLower == "high")
		{
			// Test low limit
			strSection = strString.section(':',1,1);
			m_NiParameter.fHighLimit = strSection.toFloat();
			m_NiParameter.bValidHighLimit = true;
		}
		else
		{
			// Check if this is a Module name declaration (first line of a test description)
			strSection = strString.section(':',1,1);
			strSection = strSection.trimmed();	// remove leading spaces.
			strSectionLower = strSection.toLower();

			// Extract pass/fail info
			if(strSectionLower == "skipped")
			{
				// If a previous test has to be saved to STDF file, then do it!
				if(bTestResult)
					WritePTR();

				// Write in Datalog flow that this test was skipped
				WriteDTR(strString);

				// Simply ignore this test as it has been ignored
				bTestResult = false;
			}
			else
			if(strSectionLower == "done")
			{
				// If a previous test has to be saved to STDF file, then do it!
				if(bTestResult)
					WritePTR();
	
				// Flag that we enter a valid test result
				bTestResult = true;
				m_NiParameter.strName = strKeyword;
			}
			else
			if(strSectionLower == "passed")
			{
				// If a previous test has to be saved to STDF file, then do it!
				if(bTestResult)
					WritePTR();

				// Flag that we enter a valid test result
				bTestResult = true;
				m_NiParameter.strName = strKeyword;

				// This is a module that passed
				m_NiParameter.bPassed = true;
			}
			else
			if(strSectionLower == "failed")
			{
				// If a previous test has to be saved to STDF file, then do it!
				if(bTestResult)
					WritePTR();
				
				// Flag that we enter a valid test result
				bTestResult = true;
				m_NiParameter.strName = strKeyword;

				// This is a module that failed
				m_NiParameter.bPassed = false;
			}	
			else
			if(strSectionLower.isEmpty())
			{
				// this is a comment line...ignore it
				WriteDTR(strString,"#008000");
			}
		}
	};

	// If a previous test has to be saved to STDF file, then do it!
	if(bTestResult)
		WritePTR();

	// Keep track of the number of units datalogged
	m_iTotalUnits++;

	// Write STDF.PRR
	WritePRR();

	// Process datalog of next unit (if any)
	goto parse_file;

	// File filled, so write summary & close it!
close_file:
	// Full file processed, write summary records
	WriteSBR_HBR();

	// Write PCR
	WritePCR();

	// Write last record
	WriteMRR();

	// Close STDF file.
	StdfFile.Close();

	// Success
	return true;
}

//////////////////////////////////////////////////////////////////////
// Convert 'FileName' NI-TXT file, to STDF 'strFileNameSTDF' file
//////////////////////////////////////////////////////////////////////
bool CGNItoSTDF::Convert(const char *strNiFileName, const char *strFileNameSTDF)
{
	// No erro (default)
	iLastError = errNoError;

	// If STDF file already exists...do not rebuild it...unless dates not matching!
	QFileInfo fInput(strNiFileName);
	QFileInfo fOutput(strFileNameSTDF);

    QFile f( strFileNameSTDF );
    if((f.exists() == true) && (fInput.lastModified() < fOutput.lastModified()))
		return true;

	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	bool bHideProgressAfter=true;
	bool bHideLabelAfter=false;
	if(GexProgressBar != NULL)
	{
		bHideProgressAfter = GexProgressBar->isHidden();
		GexProgressBar->setMaximum(100);
		GexProgressBar->setTextVisible(true);
		GexProgressBar->setValue(0);
		GexProgressBar->show();
	}

	if(GexScriptStatusLabel != NULL)
	{
		if(GexScriptStatusLabel->isHidden())
		{
			bHideLabelAfter = true;
			GS::Gex::Engine::GetInstance().UpdateLabelStatus("Converting data from file "+QFileInfo(strNiFileName).fileName()+"...");
			GexScriptStatusLabel->show();
		}
	}
    QCoreApplication::processEvents();

	// connvert file.
    if(!ReadNiFile(strNiFileName,strFileNameSTDF))
	{
		//////////////////////////////////////////////////////////////////////
		// For ProgressBar
		if((GexProgressBar != NULL)
		&& bHideProgressAfter)
			GexProgressBar->hide();
		
		if((GexScriptStatusLabel != NULL)
		&& bHideLabelAfter)
			GexScriptStatusLabel->hide();
		return false;
	}
	
	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	if((GexProgressBar != NULL)
	&& bHideProgressAfter)
		GexProgressBar->hide();
	
	if((GexScriptStatusLabel != NULL)
	&& bHideLabelAfter)
		GexScriptStatusLabel->hide();
	
	// connvert file.
	return true;
}

//////////////////////////////////////////////////////////////////////
// Read line : skip empty line
//////////////////////////////////////////////////////////////////////
QString CGNItoSTDF::ReadLine(QTextStream& hFile)
{
	QString strString;
	
	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	if(GexProgressBar != NULL)
	{
        while((int) hFile.device()->pos() > iNextFilePos)
		{
			iProgressStep += 100/iFileSize + 1;
			iNextFilePos  += iFileSize/100 + 1;
			GexProgressBar->setValue(iProgressStep);
		}
	}
    QCoreApplication::processEvents();
			
	do
		strString = hFile.readLine();
	while(!strString.isNull() && strString.isEmpty());

	return strString;

}
