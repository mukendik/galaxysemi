//////////////////////////////////////////////////////////////////////
// import_asl1000.cpp: Convert a ASL1000 (TMT) file to STDF V4.0
//////////////////////////////////////////////////////////////////////

#include "gqtl_global.h"
#include <qmath.h>
#include <time.h>

#ifdef _WIN32
#include "windows.h"		// For 'GetWindowsDirectoryA' declaration
#endif

#include <qfileinfo.h>
#include <qregexp.h>
#include <qprogressbar.h>
#include <qapplication.h>
#include <qlabel.h>

#include "engine.h"
#include "import_asl1000.h"
#include "import_constants.h"

extern QLabel			*GexScriptStatusLabel;	// Handle to script status text in status bar
extern QProgressBar	*	GexProgressBar;		// Handle to progress bar in status bar

// File format:
//TEXT REPORT
//
//Test Program: DEV650 Test Procedures
//Lot ID: 335294_100
//Operator: admin
//Computer: admin
//
//Date: 04/24/06 10:56:26
//
//Serial Number: 1
//|Test#   |Test Name                |    Value    |P/F|Unit|    Min      |     Max     | Notes               | 
//|1.01.00 |iddtx                    |   9999.0000 | F | uA |    360.0000 |    570.0000 | Notes               | 
//|1.01.01 |idd_delta                |      0.0000 | P | uA |     -1.0000 |     73.0000 | Notes               | 

#define BIT0			0x01
#define BIT1			0x02
#define BIT2			0x04
#define BIT3			0x08
#define BIT4			0x10
#define BIT5			0x20
#define BIT6			0x40
#define BIT7			0x80


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CGASL1000toSTDF::CGASL1000toSTDF()
{
	// Default: ASL1000 parameter list on disk includes all known ASL1000 parameters...
	m_bNewAsl1000ParameterFound = false;
	m_lStartTime = 0;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CGASL1000toSTDF::~CGASL1000toSTDF()
{
}

//////////////////////////////////////////////////////////////////////
// Get Error
//////////////////////////////////////////////////////////////////////
QString CGASL1000toSTDF::GetLastError()
{
	m_strLastError = "Import ASL1000: ";

	switch(m_iLastError)
	{
		default:
		case errNoError:
			m_strLastError += "No Error";
			break;
		case errOpenFail:
			m_strLastError += "Failed to open file";
			break;
		case errInvalidFormat:
			m_strLastError += "Invalid file format";
			break;
		case errWriteSTDF:
			m_strLastError += "Failed creating temporary file. Folder permission issue?";
			break;	
		case errLicenceExpired:
			m_strLastError += "License has expired or Data file out of date...";
			break;	
	}
	// Return Error Message
	return m_strLastError;
}

//////////////////////////////////////////////////////////////////////
// Load ASL1000 Parameter table from DISK
//////////////////////////////////////////////////////////////////////
void CGASL1000toSTDF::LoadParameterIndexTable(void)
{
	QString	strAsl1000TableFile;
	QString	strString;

    strAsl1000TableFile  = GS::Gex::Engine::GetInstance().Get("UserFolder").toString();
	strAsl1000TableFile += GEX_ASL1000_PARAMETERS;

	// Open ASL1000 Parameter table file
    QFile f( strAsl1000TableFile );
    if(!f.open(QIODevice::ReadOnly))
		return;

	// Assign file I/O stream
	QTextStream hAsl1000TableFile(&f);

	// Skip comment or empty lines
	do
	{
	  strString = hAsl1000TableFile.readLine();
	}
    while((strString.indexOf("----------------------") < 0) && (!hAsl1000TableFile.atEnd()));

	// Read lines
	m_pFullAsl1000ParametersList.clear();
	strString = hAsl1000TableFile.readLine();
	while (strString.isNull() == false)
	{
		// Save Parameter name in list
		m_pFullAsl1000ParametersList.append(strString);
		// Read next line
		strString = hAsl1000TableFile.readLine();
	};

	// Close file
	f.close();
}

//////////////////////////////////////////////////////////////////////
// Save ASL1000 Parameter table to DISK
//////////////////////////////////////////////////////////////////////
void CGASL1000toSTDF::DumpParameterIndexTable(void)
{
	QString		strAsl1000TableFile;

    strAsl1000TableFile  = GS::Gex::Engine::GetInstance().Get("UserFolder").toString();
	strAsl1000TableFile += GEX_ASL1000_PARAMETERS;

	// Open ASL1000 Parameter table file
    QFile f( strAsl1000TableFile );
    if(!f.open( QIODevice::WriteOnly ))
		return;

	// Assign file I/O stream
	QTextStream hAsl1000TableFile(&f);

	// First few lines are comments:
	hAsl1000TableFile << "############################################################" << endl;
	hAsl1000TableFile << "# DO NOT EDIT THIS FILE!" << endl;
    hAsl1000TableFile << "# Quantix Examinator: ASL1000 Parameters detected" << endl;
	hAsl1000TableFile << "# www.mentor.com" << endl;
    hAsl1000TableFile << "# Quantix Examinator reads and writes into this file..." << endl;
	hAsl1000TableFile << "-----------------------------------------------------------" << endl;

	// Write lines
	// m_pFullAsl1000ParametersList.sort();
	for (QStringList::const_iterator
		 iter  = m_pFullAsl1000ParametersList.begin();
		 iter != m_pFullAsl1000ParametersList.end(); ++iter) {
		// Write line
		hAsl1000TableFile << *iter << endl;
	}

	// Close file
	f.close();
}

//////////////////////////////////////////////////////////////////////
// If Examinator doesn't have this ASL1000 parameter in his dictionnary, have it added.
//////////////////////////////////////////////////////////////////////
void CGASL1000toSTDF::UpdateParameterIndexTable(QString strParamName)
{
	// Check if the table is empty...if so, load it from disk first!
	if(m_pFullAsl1000ParametersList.isEmpty() == true)
	{
		// Load ASL1000 parameter table from disk...
		LoadParameterIndexTable();
	}
	
	// Check if Parameter name already in table...if not, add it to the list
	// the new full list will be dumped to the disk at the end.
    if(m_pFullAsl1000ParametersList.indexOf(strParamName) < 0)
	{
		// Update list
		m_pFullAsl1000ParametersList.append(strParamName);

		// Set flag to force the current ASL1000 table to be updated on disk
		m_bNewAsl1000ParameterFound = true;
	}
}


//////////////////////////////////////////////////////////////////////
// Normalize test limits when writing into PTR.
//////////////////////////////////////////////////////////////////////
void CGASL1000toSTDF::NormalizeLimits(QString &strUnit, int &nScale)
{
	nScale = 0;
	if(strUnit.length() <= 1)
	{
		// units too short to include a prefix, then keep it 'as-is'
		return;
	}

	QChar cPrefix = strUnit[0];
	switch(cPrefix.toLatin1())
	{
		case 'm': // Milli
			nScale = -3;
			break;
		case 'u': // Micro
			nScale = -6;
			break;
		case 'n': // Nano
			nScale = -9;
			break;
		case 'p': // Pico
			nScale = -12;
			break;
		case 'f': // Fento
			nScale = -15;
			break;
		case 'K': // Kilo
			nScale = 3;
			break;
		case 'M': // Mega
			nScale = 6;
			break;
		case 'G': // Giga
			nScale = 9;
			break;
		case 'T': // Tera
			nScale = 12;
			break;
	}
	if(nScale)
		strUnit = strUnit.mid(1);	// Take all characters after the prefix.
}

//////////////////////////////////////////////////////////////////////
// Check if File is compatible with asl1000 format
//////////////////////////////////////////////////////////////////////
bool CGASL1000toSTDF::IsCompatible(const char *szFileName)
{
	QString strString;
	QString strSection;
	QString strValue;
	QString	strSite;

	// Open ASL1000 file
    QFile f( szFileName );
    if(!f.open( QIODevice::ReadOnly ))
	{
		// Failed Opening ASL1000 file
		return false;
	}
	// Assign file I/O stream
	QTextStream hAsl1000File(&f);

	// Check if first line is the correct ASL1000 header...
	//TEXT REPORT
	
	do
		strString = hAsl1000File.readLine();
	while(!strString.isNull() && strString.isEmpty());

	f.close();
	
	if(strString.simplified().toUpper() != "TEXT REPORT")
	{
		// Incorrect header...this is not a ASL1000 file!
		return false;
	}


	return true;
}

//////////////////////////////////////////////////////////////////////
// Read and Parse the ASL1000 file
//////////////////////////////////////////////////////////////////////
bool CGASL1000toSTDF::ReadAsl1000File(const char *Asl1000FileName,const char *strFileNameSTDF)
{
	QString strString;
	QString strSection;
	QString strValue;
	QString	strSite;

	// Open ASL1000 file
    QFile f( Asl1000FileName );
    if(!f.open( QIODevice::ReadOnly ))
	{
		// Failed Opening ASL1000 file
		m_iLastError = errOpenFail;
		
		// Convertion failed.
		return false;
	}

	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	iNextFilePos = 0;
	iProgressStep = 0;
	iFileSize = f.size() + 1;
	

	// Assign file I/O stream
	QTextStream hAsl1000File(&f);

	// Check if first line is the correct ASL1000 header...
	//TEXT REPORT
	
	strString = ReadLine(hAsl1000File);

	if(strString.simplified().toUpper() != "TEXT REPORT")
	{
		// Incorrect header...this is not a ASL1000 file!
		m_iLastError = errInvalidFormat;
		
		// Convertion failed.
		// Close file
		f.close();
		return false;
	}

	strString = "";
	// Read ASL1000 information
	//Test Program: DEV650 Test Procedures
	//Lot ID: 335294_100
	//Operator: admin
	//Computer: admin
	//
	//Date: 04/24/06 10:56:26
	//
	//Serial Number: 1
	while(!hAsl1000File.atEnd())
	{
		if(strString.isEmpty())
			strString = ReadLine(hAsl1000File);

		strSection = strString.section(":",0,0).toUpper();
		strString = strString.section(":",1);

		if(strSection == "TEST PROGRAM")
		{
			m_strProgramId = strString.simplified();
			strString = "";
		}
		else if(strSection == "LOT ID")
		{
			m_strLotId = strString.simplified();
			strString = "";
		}
		else if(strSection == "OPERATOR")
		{
			m_strOperatorId = strString.simplified();
			strString = "";
		}
		else if(strSection == "COMPUTER")
		{
			m_strComputerId = strString.simplified();
			strString = "";
		}
		else if(strSection == "DATE")
		{
			strString = strString.simplified();
			QString	strDate = strString.section(" ",0,0);
			QDate	clDate(2000+strDate.section("/",2,2).toInt(),strDate.section("/",0,0).toInt(),strDate.section("/",1,1).toInt());
			QTime	clTime = QTime::fromString(strString.section(" ",1,1));
			
			m_lStartTime = QDateTime(clDate,clTime,Qt::UTC).toTime_t();
			strString = "";
		}
		else if(strSection == "SERIAL NUMBER")
		{
			// begining of data
			break;
		}
		else
		{
			// Incorrect header...this is not a ASL1000 file!
			m_iLastError = errInvalidFormat;
			
			// Convertion failed.
			// Close file
			f.close();
			return false;
		}
	}

	// It's a ASL1000 file
	// Reset file position and start to write STDF file
	f.close();

 	// Open VERIGY_EDF file
	FILE *fp = fopen(Asl1000FileName,"r");   
    if(!fp)
	{
		// Failed Opening VERIGY_EDF file
		m_iLastError = errOpenFail;
		
		// Convertion failed.
		return false;
	}
	
	if(!WriteStdfFile(fp,strFileNameSTDF))
	{
		fclose(fp);
		return false;
	}

	// Close file
	fclose(fp);
	
	// All ASL1000 file read...check if need to update the ASL1000 Parameter list on disk?
	if(m_bNewAsl1000ParameterFound == true)
		DumpParameterIndexTable();

	// Success parsing ASL1000 file
	return true;
}

//////////////////////////////////////////////////////////////////////
// Create STDF file from ASL1000 data parsed
//////////////////////////////////////////////////////////////////////
bool CGASL1000toSTDF::WriteStdfFile(FILE *fp,const char *strFileNameSTDF)
{
	// now generate the STDF file...
    GS::StdLib::Stdf StdfFile;
    GS::StdLib::StdfRecordReadInfo RecordReadInfo;
    if(StdfFile.Open((char*)strFileNameSTDF,STDF_WRITE) != GS::StdLib::Stdf::NoError)
	{
		// Failed importing ASL1000 file into STDF database
		m_iLastError = errWriteSTDF;
		
		// Convertion failed.
		return false;
	}


	// Write FAR
	RecordReadInfo.iRecordType = 0;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(1);					// SUN CPU type
	StdfFile.WriteByte(4);					// STDF V4
	StdfFile.WriteRecord();

	if(m_lStartTime <= 0)
		m_lStartTime = QDateTime::currentDateTime().toTime_t();

	// Write MIR
	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 10;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteDword(m_lStartTime);			// Setup time
	StdfFile.WriteDword(m_lStartTime);			// Start time
	StdfFile.WriteByte(1);						// Station
	StdfFile.WriteByte((BYTE) 'P');				// Test Mode = PRODUCTION
	StdfFile.WriteByte((BYTE) ' ');				// rtst_cod
	StdfFile.WriteByte((BYTE) ' ');				// prot_cod
	StdfFile.WriteWord(65535);					// burn_tim
	StdfFile.WriteByte((BYTE) ' ');				// cmod_cod
	StdfFile.WriteString(m_strLotId.toLatin1().constData());		// Lot ID
	StdfFile.WriteString("");					// Part Type / Product ID
	StdfFile.WriteString("");					// Node name
	StdfFile.WriteString(m_strComputerId.toLatin1().constData());	// Tester Type
	StdfFile.WriteString(m_strProgramId.toLatin1().constData());	// Job name
	StdfFile.WriteString("");					// Job rev
	StdfFile.WriteString("");					// sublot-id
	StdfFile.WriteString(m_strOperatorId.toLatin1().constData());	// operator
	StdfFile.WriteString("");					// exec-type
	StdfFile.WriteString("");					// exe-ver
	StdfFile.WriteString("");					// test-cod
	StdfFile.WriteString("");					// test-temperature
	// Construct custom Galaxy USER_TXT 
	QString	strUserTxt;
	strUserTxt = GEX_IMPORT_DATAORIGIN_LABEL;	
	strUserTxt += ":";
	strUserTxt += GEX_IMPORT_DATAORIGIN_ATETEST;
	strUserTxt += ":TMT_ASL1000";
	StdfFile.WriteString(strUserTxt.toLatin1().constData());		// user-txt
	StdfFile.WriteString("");					// aux-file
	StdfFile.WriteString("");					// package-type
	StdfFile.WriteString("");					// familyID
	StdfFile.WriteString("");					// Date-code
	StdfFile.WriteString("");					// Facility-ID
	StdfFile.WriteString("");					// FloorID
	StdfFile.WriteString("");					// ProcessID

	StdfFile.WriteRecord();

	// Write Test results for each line read.
	QString		strString;
	QString		strSection;
 	//FIXME: not used ?
  //WORD wSoftBin;
  //WORD wHardBin;
	long		iTotalGoodBin,iTotalFailBin;
	long		iTotalTests,iPartNumber;
	bool		bPassStatus;
	BYTE		bData;

	int			iBin;
	int			iTestNumber;
	bool		bTestPass=false;
	QString		strTestName;
	QString		strNotes;
	QString		strUnit;
	int			nScale;
	float		fValue;
	float		fLowLimit, fHighLimit;
	bool		bTestAlreadySaved;
	bool		bHaveLowLimit=false, bHaveHighLimit=false;
	QMap<int,int> mapTestNumberWithScale;
	QStringList	lstSections;

	char		szBuffer[2048+1];
    char		*szString;

	// Reset counters
	iTotalGoodBin=iTotalFailBin=0;
	iPartNumber=0;

	// Write all Parameters read on this file : PIR,PTR...,PRR, PIR,PTR..., PRR

	//Serial Number: 1
	//|Test#   |Test Name                |    Value    |P/F|Unit|    Min      |     Max     | Notes               | 
	//|1.01.00 |iddtx                    |   9999.0000 | F | uA |    360.0000 |    570.0000 | Notes               | 
	//|1.01.01 |idd_delta                |      0.0000 | P | uA |     -1.0000 |     73.0000 | Notes               | 
	
	QRegExp clRegSpace("[\\s\\t]+");
	QRegExp clRegPoint("[\\s\\t\\.]+");
	// Read ASL1000 information
	while(!feof(fp))
	{
		if(strString.isEmpty())
		{
			// read line and remove space
			ReadLine(fp,szBuffer);
			
			if(strlen(szBuffer) == 0)
				continue;
			
			strString = szBuffer;
			strString = strString.remove(clRegSpace);
		}
		if(strString.isEmpty())
			continue;

		strSection = strString.section(":",0,0);
		strString = strString.section(":",1);

		if(strSection == "SerialNumber")
		{
			iPartNumber = strString.toInt();

			//////////////////////////////////////////////////////////////////////
			// For ProgressBar
			if(GexProgressBar != NULL)
			{
				while((int) ftell(fp) > iNextFilePos)
				{
					iProgressStep += 100/iFileSize + 1;
					iNextFilePos  += iFileSize/100 + 1;
					GexProgressBar->setValue(iProgressStep);
				}
			}
            QCoreApplication::processEvents();
			
			// Write PIR
			// Write PIR for parts in this Wafer site
			RecordReadInfo.iRecordType = 5;
			RecordReadInfo.iRecordSubType = 10;
			StdfFile.WriteHeader(&RecordReadInfo);
			StdfFile.WriteByte(1);					// Test head
			StdfFile.WriteByte(1);					// Tester site
			StdfFile.WriteRecord();

			// Reset Pass/Fail flag.
			bPassStatus = true;
			iBin = 0;

			// Reset counters
			iTotalTests = 0;

			//|Test#   |Test Name       |  Value      |P/F|Unit    |Min Limit    |MaxLimit     |  Notes       |
			// ignore this header
			ReadLine(fp,szBuffer);

			while(!feof(fp))
			{
				ReadLine(fp,szBuffer);
				if(strlen(szBuffer) == 0)
				{
					strString = "";
					break;
				}
				if(szBuffer[0]!='|')
				{
					strString = szBuffer;
					break;
				}

				// reset values
				strTestName = strUnit = "";
				fValue = fLowLimit = fHighLimit = 0;
				bTestAlreadySaved = false;

				strString = strtok (szBuffer,"|");
				iTestNumber = strString.remove('.').simplified().toInt();

				strString = strtok (NULL, "|");
				strTestName = strString.simplified();

				szString = strtok (NULL, "|");
				if((szString!=NULL) && (strlen(szString) > 0))
					sscanf(szString,"%f",&fValue);
				else
					fValue = 0;
				
				szString = strtok (NULL, "|");
				if((szString!=NULL) && (strlen(szString) > 0))
					bTestPass = (strchr(szString,'F') == NULL);
				if(mapTestNumberWithScale.contains(iTestNumber))
				{
					nScale = mapTestNumberWithScale[iTestNumber];
					bTestAlreadySaved = true;
				}
				else
				{
					bHaveLowLimit = bHaveHighLimit = false;
					strUnit = strtok (NULL, "|");
					strUnit = strUnit.simplified();
					
					szString = strtok (NULL, "|");
					if((szString!=NULL) && (strlen(szString) > 0))
						bHaveLowLimit = (sscanf(szString,"%f",&fLowLimit) == 1);

					szString = strtok (NULL, "|");
					if((szString!=NULL) && (strlen(szString) > 0))
						bHaveHighLimit = (sscanf(szString,"%f",&fHighLimit) == 1);

					strNotes = strtok (NULL, "|");
					strNotes = strNotes.simplified();
					if(!strNotes.isEmpty() && !strNotes.startsWith("Notes", Qt::CaseInsensitive))
						strTestName += "(" + strNotes + ")";

					if(strUnit.startsWith("_"))
						strUnit = "";
					if(!strUnit.isEmpty())
						NormalizeLimits(strUnit, nScale);
					mapTestNumberWithScale[iTestNumber] = nScale;

					UpdateParameterIndexTable(strTestName);
				}

				iTotalTests++;
				bPassStatus &= bTestPass;



				// Write PTR
				RecordReadInfo.iRecordType = 15;
				RecordReadInfo.iRecordSubType = 10;
				
				StdfFile.WriteHeader(&RecordReadInfo);
				StdfFile.WriteDword(iTestNumber);	// Test Number
				StdfFile.WriteByte(1);			// Test head
				StdfFile.WriteByte(1);			// Tester site:1,2,3,4 or 5, etc.
				if(bTestPass)
					bData = 0;		// Test passed
				else
					bData = BIT7;	// Test Failed
				StdfFile.WriteByte(bData);							// TEST_FLG
				if(bHaveLowLimit)
					bData |= BIT6;
				if(bHaveHighLimit)
					bData |= BIT7;
				StdfFile.WriteByte(bData);							// PARAM_FLG
				StdfFile.WriteFloat(fValue * GS_POW(10.0,nScale));		// Test result
				if(!bTestAlreadySaved)
				{
					// save Parameter name without unit information
					StdfFile.WriteString(strTestName.toLatin1().constData());	// TEST_TXT
					StdfFile.WriteString("");								// ALARM_ID

					bData = 2;	// Valid data.
					if(!bHaveLowLimit)
						bData |= BIT6;
					if(!bHaveHighLimit)
						bData |= BIT7;
					StdfFile.WriteByte(bData);							// OPT_FLAG

					StdfFile.WriteByte(-nScale);						// RES_SCALE
					StdfFile.WriteByte(-nScale);						// LLM_SCALE
					StdfFile.WriteByte(-nScale);						// HLM_SCALE
					StdfFile.WriteFloat(fLowLimit * GS_POW(10.0,nScale));	// LOW Limit
					StdfFile.WriteFloat(fHighLimit * GS_POW(10.0,nScale));	// HIGH Limit
					StdfFile.WriteString(strUnit.toLatin1().constData());	// Units
				}
				StdfFile.WriteRecord();
			}
			// Write PRR
			RecordReadInfo.iRecordType = 5;
			RecordReadInfo.iRecordSubType = 20;
			StdfFile.WriteHeader(&RecordReadInfo);
			StdfFile.WriteByte(1);				// Test head
			StdfFile.WriteByte(1);				// Tester site:1,2,3,4 or 5
			if(bPassStatus)
			{
				StdfFile.WriteByte(0);				// PART_FLG : PASSED
				iTotalGoodBin++;
				iBin = 1;
			}
			else
			{
				StdfFile.WriteByte(8);				// PART_FLG : FAILED
				iTotalFailBin++;
				iBin = 0;
			}
      //FIXME: not used ?
      //wSoftBin = wHardBin = iBin;
			StdfFile.WriteWord((WORD)iTotalTests);	// NUM_TEST
			StdfFile.WriteWord(iBin);				// HARD_BIN
			StdfFile.WriteWord(iBin);				// SOFT_BIN
			StdfFile.WriteWord((WORD)-32768);		// X_COORD
			StdfFile.WriteWord((WORD)-32768);		// Y_COORD
			StdfFile.WriteDword(0);					// No testing time known...
			StdfFile.WriteString(QString::number(iPartNumber).toLatin1().constData());// PART_ID
			StdfFile.WriteString("");				// PART_TXT
			StdfFile.WriteString("");				// PART_FIX
			StdfFile.WriteRecord();
		}
		else
			strString="";
	}


	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 40;
	// Write HBR
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);						// Test Head = ALL
	StdfFile.WriteByte(255);						// Test sites = ALL		
	StdfFile.WriteWord(0);							// HBIN = 0
	StdfFile.WriteDword(iTotalFailBin);	// Total Bins
	StdfFile.WriteByte('F');
	StdfFile.WriteString("");
	StdfFile.WriteRecord();

	// Write HBR
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);						// Test Head = ALL
	StdfFile.WriteByte(255);						// Test sites = ALL		
	StdfFile.WriteWord(1);							// HBIN = 1
	StdfFile.WriteDword(iTotalGoodBin);				// Total Bins
	StdfFile.WriteByte('P');
	StdfFile.WriteString("");
	StdfFile.WriteRecord();

	RecordReadInfo.iRecordType = 1;
	RecordReadInfo.iRecordSubType = 50;
	// Write SBR
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);						// Test Head = ALL
	StdfFile.WriteByte(255);						// Test sites = ALL		
	StdfFile.WriteWord(0);							// HBIN = 0
	StdfFile.WriteDword(iTotalFailBin);	// Total Bins
	StdfFile.WriteByte('F');
	StdfFile.WriteString("");
	StdfFile.WriteRecord();

	// Write SBR
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteByte(255);						// Test Head = ALL
	StdfFile.WriteByte(255);						// Test sites = ALL		
	StdfFile.WriteWord(1);							// HBIN = 1
	StdfFile.WriteDword(iTotalGoodBin);				// Total Bins
	StdfFile.WriteByte('P');
	StdfFile.WriteString("");
	StdfFile.WriteRecord();

	// Write MRR
	RecordReadInfo.iRecordType = 1; 
	RecordReadInfo.iRecordSubType = 20;
	StdfFile.WriteHeader(&RecordReadInfo);
	StdfFile.WriteDword(m_lStartTime);			// File finish-time.
	StdfFile.WriteRecord();

	// Close STDF file.
	StdfFile.Close();
	
	// Success
	return true;
}

//////////////////////////////////////////////////////////////////////
// Convert 'FileName' ASL1000 file, to STDF 'strFileNameSTDF' file
//////////////////////////////////////////////////////////////////////
bool CGASL1000toSTDF::Convert(const char *Asl1000FileName, const char *strFileNameSTDF)
{
	// No erro (default)
	m_iLastError = errNoError;

	// If STDF file already exists...do not rebuild it...unless dates not matching!
	QFileInfo fInput(Asl1000FileName);
	QFileInfo fOutput(strFileNameSTDF);

    QFile f( strFileNameSTDF );
    if((f.exists() == true) && (fInput.lastModified() < fOutput.lastModified()))
		return true;

	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	bool bHideProgressAfter=true;
	bool bHideLabelAfter=false;
	if(GexProgressBar != NULL)
	{
		bHideProgressAfter = GexProgressBar->isHidden();
		GexProgressBar->setMaximum(100);
		GexProgressBar->setTextVisible(true);
		GexProgressBar->setValue(0);
		GexProgressBar->show();
	}

	if(GexScriptStatusLabel != NULL)
	{
		if(GexScriptStatusLabel->isHidden())
		{
			bHideLabelAfter = true;
			GS::Gex::Engine::GetInstance().UpdateLabelStatus("Converting data from file "+QFileInfo(Asl1000FileName).fileName()+"...");
			GexScriptStatusLabel->show();
		}
	}
    QCoreApplication::processEvents();

    if(ReadAsl1000File(Asl1000FileName,strFileNameSTDF) != true)
	{
		QFile::remove(strFileNameSTDF);
		//////////////////////////////////////////////////////////////////////
		// For ProgressBar
		if((GexProgressBar != NULL)
		&& bHideProgressAfter)
			GexProgressBar->hide();
		
		if((GexScriptStatusLabel != NULL)
		&& bHideLabelAfter)
			GexScriptStatusLabel->hide();

		return false;
	}

	//////////////////////////////////////////////////////////////////////
	// For ProgressBar
	if((GexProgressBar != NULL)
	&& bHideProgressAfter)
		GexProgressBar->hide();
	
	if((GexScriptStatusLabel != NULL)
	&& bHideLabelAfter)
		GexScriptStatusLabel->hide();
	
	// Convertion successful
	return true;
}

//////////////////////////////////////////////////////////////////////
// Read line : skip empty line
//////////////////////////////////////////////////////////////////////
QString CGASL1000toSTDF::ReadLine(QTextStream& hFile)
{
	QString strString;
	
	do
		strString = hFile.readLine();
	while(!strString.isNull() && strString.isEmpty());

	return strString;

}

//////////////////////////////////////////////////////////////////////
// Read line
//////////////////////////////////////////////////////////////////////
int CGASL1000toSTDF::ReadLine(FILE *fp, char *bp)
{
   char c = '\0';
    int i = 0;
    
	if(feof(fp))
	{
		bp[i] = '\0';
		return 0;
	}

	// Read one line from the source file
    while( (c = getc(fp)) != '\n' )
    {   
		if( c == EOF )         /* return false on unexpected EOF */
		{
		    bp[i] = '\0';
            return 0;
		}
        bp[i++] = c;
    }
    bp[i] = '\0';

    QCoreApplication::processEvents();
    return 1;
}
